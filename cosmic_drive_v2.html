<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ATOMICFORGE - Level 0: Particle Soup</title>
    <style>
        :root {
            --primary-color: #0FF;
            --secondary-color: #F06;
            --success-color: #0F6;
            --warning-color: #FF0;
            --text-color: #FFF;
            --bg-color: #000;
            --panel-bg: rgba(0, 20, 40, 0.9);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: var(--bg-color);
            font-family: 'Courier New', monospace;
            color: var(--primary-color);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #canvas {
            flex: 1;
            display: block;
            background: var(--bg-color);
        }

        .controls {
            background: var(--panel-bg);
            padding: 20px;
            border-top: 2px solid var(--primary-color);
            box-shadow: 0 -5px 30px rgba(0, 255, 255, 0.3); /* Kept as specific color for the glow effect */
            max-height: 40vh;
            overflow-y: auto;
        }

        #protoforge-controls {
            display: none; /* Hidden by default */
        }

        .protoforge-status {
            position: fixed;
            top: 150px;
            left: 20px;
            background: var(--panel-bg);
            border: 2px solid var(--primary-color);
            padding: 15px;
            border-radius: 5px;
            z-index: 50;
            max-width: 250px;
            display: none; /* Hidden by default */
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-group span {
            min-width: 200px;
        }

        input[type="range"] {
            flex: 1;
            height: 4px;
            background: var(--primary-color);
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
            -webkit-appearance: none;
            appearance: none;
        }

        input[type="range"]:hover {
            opacity: 1;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--primary-color);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--primary-color);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            border: none;
        }

        .value {
            min-width: 60px;
            text-align: right;
            font-weight: bold;
            color: var(--text-color);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(0, 255, 255, 0.3);
        }

        .stat {
            background: rgba(0, 255, 255, 0.1);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        .stat-label {
            font-size: 11px;
            opacity: 0.7;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: var(--text-color);
        }

        .achievement {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: rgba(0, 0, 0, 0.95); /* Kept specific for popups */
            border: 3px solid var(--primary-color);
            padding: 40px;
            text-align: center;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.8);
            z-index: 1000;
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .achievement.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        .achievement-title {
            font-size: 32px;
            margin-bottom: 10px;
            color: var(--primary-color);
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
        }

        .achievement-subtitle {
            font-size: 18px;
            color: var(--text-color);
            margin-bottom: 20px;
        }

        .achievement-desc {
            font-size: 14px;
            opacity: 0.8;
        }

        .tutorial {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9); /* Kept specific for popups */
            border: 2px solid var(--primary-color);
            padding: 20px 30px;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            max-width: 600px;
            z-index: 100;
        }

        .tutorial-text {
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .tutorial-hint {
            font-size: 12px;
            opacity: 0.7;
            font-style: italic;
        }

        button {
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid var(--primary-color);
            color: var(--primary-color);
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 15px;
        }

        button:hover {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        button.danger {
            border-color: var(--secondary-color);
            color: var(--secondary-color);
            background: rgba(255, 0, 102, 0.2);
        }

        button.danger:hover {
            background: rgba(255, 0, 102, 0.4);
            box-shadow: 0 0 20px var(--secondary-color);
        }

        button.success {
            border-color: var(--success-color);
            color: var(--success-color);
            background: rgba(0, 255, 102, 0.2);
        }

        button.success:hover {
            background: rgba(0, 255, 102, 0.4);
            box-shadow: 0 0 20px rgba(0, 255, 102, 0.6);
        }

        button.toggled {
            background: var(--primary-color);
            color: var(--bg-color);
            box-shadow: 0 0 15px var(--primary-color);
        }
        button.toggled:hover {
            background: #3ff;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .button-group button {
            flex: 1;
            min-width: 120px;
            margin: 0;
        }

        .status-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 5px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 16px;
            font-weight: bold;
        }

                .level-up-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: rgba(0, 0, 0, 0.95); /* Kept specific for popups */
            border: 3px solid var(--primary-color);
            padding: 30px 40px;
            text-align: center;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.8);
            z-index: 2000;
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            min-width: 350px;
        }

        .level-up-popup.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        .level-up-title {
            font-size: 32px;
            margin-bottom: 10px;
            color: var(--primary-color);
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
            animation: pulse 2s infinite;
        }

        .level-up-subtitle {
            font-size: 18px;
            color: var(--text-color);
            margin-bottom: 15px;
        }

        .level-up-unlocks {
            font-size: 14px;
            opacity: 0.9;
            background: rgba(0, 255, 255, 0.1);
            padding: 10px;
            border-radius: 5px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--success-color);
            box-shadow: 0 0 10px rgba(0, 255, 102, 0.8);
        }

        .status-dot.paused {
            background: var(--warning-color);
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.8);
        }

        .status-dot.stopped {
            background: var(--secondary-color);
            box-shadow: 0 0 10px rgba(255, 0, 102, 0.8);
        }

        .timer {
            font-size: 20px;
            font-weight: bold;
            color: var(--text-color);
            font-variant-numeric: tabular-nums;
        }

        .level-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--primary-color);
            padding: 10px 20px;
            border-radius: 5px;
            text-align: center;
            z-index: 50;
        }

        .level-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .level-progress {
            height: 6px;
            background: rgba(0, 255, 255, 0.2);
            border-radius: 3px;
            overflow: hidden;
        }

        .level-progress-bar {
            height: 100%;
            background: var(--primary-color);
            width: 0%;
            transition: width 0.5s;
        }

        .element-key {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--primary-color);
            padding: 10px;
            border-radius: 5px;
            z-index: 50;
            max-width: 200px;
            transition: all 0.3s ease;
        }

        .element-key.minimized {
            padding: 8px 12px;
            max-width: auto;
        }

        .element-key.minimized .key-content {
            display: none;
        }

        .element-key h3 {
            margin-bottom: 10px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            -webkit-user-select: none;
            user-select: none;
        }

        .element-key.minimized h3 {
            margin-bottom: 0;
        }

        .element-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .element-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .molecule-list {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--primary-color);
            padding: 10px;
            border-radius: 5px;
            z-index: 50;
            max-width: 200px;
            max-height: 300px;
            overflow-y: auto;
            transition: all 0.3s ease;
        }

        .molecule-list.minimized {
            padding: 8px 12px;
            max-width: auto;
            max-height: auto;
            overflow: hidden;
        }

        .molecule-list.minimized .list-content {
            display: none;
        }

        .molecule-list h3 {
            margin-bottom: 10px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            -webkit-user-select: none;
            user-select: none;
        }

        .molecule-list.minimized h3 {
            margin-bottom: 0;
        }

        .molecule-item {
            font-size: 12px;
            margin-bottom: 5px;
            padding: 5px;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 3px;
        }

        .toggle-icon {
            font-size: 14px;
            margin-left: 10px;
        }

        .toggle-icon {
            display: inline-block;
            padding: 2px 8px;
            border: 1px solid var(--primary-color);
            background: rgba(0, 255, 255, 0.1);
            border-radius: 3px;
            font-weight: bold;
            transition: all 0.2s ease;
            -webkit-user-select: none;
            user-select: none;
        }

        .toggle-icon:hover {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .toggle-icon:active {
            transform: scale(0.9);
            background: var(--primary-color);
            color: var(--bg-color);
        }

        .achievements-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--primary-color);
            padding: 10px;
            border-radius: 5px;
            z-index: 50;
            max-width: 300px;
            max-height: 400px;
            overflow-y: auto;
            transition: all 0.3s ease;
        }

        .achievements-panel.minimized {
            padding: 8px 12px;
            max-width: auto;
            max-height: auto;
            overflow: hidden;
        }

        .achievements-panel.minimized .achievements-content {
            display: none;
        }

        .achievements-panel h3 {
            margin-bottom: 10px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            -webkit-user-select: none;
            user-select: none;
        }

        .achievements-panel.minimized h3 {
            margin-bottom: 0;
        }

        .achievement-item {
            margin-bottom: 12px;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .achievement-item.unlocked {
            background: rgba(0, 255, 255, 0.15);
            border-color: var(--primary-color);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        .achievement-item.locked {
            background: rgba(100, 100, 100, 0.1);
            border-color: rgba(100, 100, 100, 0.3);
            opacity: 0.6;
        }

        .achievement-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
        }

        .achievement-icon {
            font-size: 20px;
        }

        .achievement-title {
            font-size: 13px;
            font-weight: bold;
            flex: 1;
        }

        .achievement-status {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .achievement-status.unlocked {
            background: var(--success-color);
            color: #000;
        }

        .achievement-status.locked {
            background: rgba(100, 100, 100, 0.5);
            color: #888;
        }

        .achievement-desc {
            font-size: 11px;
            opacity: 0.8;
            line-height: 1.4;
        }

        .achievement-progress {
            margin-top: 5px;
            font-size: 10px;
            opacity: 0.7;
        }

        .progress-bar {
            height: 4px;
            background: rgba(0, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 3px;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary-color);
            transition: width 0.3s ease;
        }

        .achievement-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: rgba(0, 0, 0, 0.95); /* Kept specific for popups */
            border: 3px solid var(--primary-color);
            padding: 30px 40px;
            text-align: center;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.8);
            z-index: 2000;
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            min-width: 350px;
        }

        .achievement-popup.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        .achievement-popup-icon {
            font-size: 64px;
            margin-bottom: 15px;
            animation: pulse 2s infinite;
        }

        .achievement-popup-title {
            font-size: 28px;
            margin-bottom: 10px;
            color: var(--primary-color);
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
        }

        .achievement-popup-subtitle {
            font-size: 16px;
            color: var(--text-color);
            margin-bottom: 15px;
        }

        .achievement-popup-desc {
            font-size: 13px;
            opacity: 0.8;
            line-height: 1.5;
        }

        .achievement-popup-xp {
            margin-top: 15px;
            font-size: 18px;
            color: var(--success-color);
            font-weight: bold;
        }

        .achievements-summary {
            padding: 10px;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 5px;
            margin-bottom: 15px;
            text-align: center;
        }

        .summary-text {
            font-size: 14px;
            font-weight: bold;
        }

        .summary-progress {
            font-size: 12px;
            opacity: 0.8;
            margin-top: 5px;
        }

        /* ACHIEVEMENT HELP STYLES */
        .achievement-help {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: rgba(0, 0, 0, 0.95); /* Kept specific for popups */
            border: 3px solid var(--primary-color);
            padding: 30px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.8);
            z-index: 2000;
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .achievement-help.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        .help-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 15px;
        }

        .help-icon {
            font-size: 48px;
        }

        .help-title {
            font-size: 24px;
            color: var(--primary-color);
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .help-xp {
            font-size: 18px;
            color: var(--success-color);
            font-weight: bold;
        }

        .help-section {
            margin-bottom: 20px;
        }

        .help-section h3 {
            color: var(--primary-color);
            margin-bottom: 10px;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .help-section p {
            line-height: 1.5;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .strategy-list {
            list-style: none;
            padding-left: 0;
        }

        .strategy-list li {
            margin-bottom: 8px;
            padding-left: 20px;
            position: relative;
        }

        .strategy-list li:before {
            content: "‚öõÔ∏è";
            position: absolute;
            left: 0;
        }

        .parameter-recommendations {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .param-item {
            background: rgba(0, 255, 255, 0.1);
            padding: 8px;
            border-radius: 5px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        .param-label {
            font-size: 11px;
            opacity: 0.7;
            margin-bottom: 3px;
        }

        .param-value {
            font-size: 14px;
            font-weight: bold;
            color: var(--primary-color);
        }

        .molecule-formula {
            font-family: 'Courier New', monospace;
            background: rgba(0, 255, 255, 0.1);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            margin: 10px 0;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        .close-help {
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid var(--primary-color);
            color: var(--primary-color);
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            width: 100%;
            margin-top: 15px;
        }

        .close-help:hover {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
        }

        .achievement-item.clickable {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .achievement-item.clickable:hover {
            transform: translateX(5px);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
        }

        .current-progress {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 5px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        .progress-info {
            font-size: 12px;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .hint-tip {
            background: rgba(255, 255, 0, 0.1);
            border: 1px solid rgba(255, 255, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 12px;
        }

        .param-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.3s ease;
        }

        .param-item.in-range {
            background-color: rgba(0, 255, 102, 0.15);
            border-color: rgba(0, 255, 102, 0.4);
        }

        .param-item.out-of-range {
            background-color: rgba(255, 0, 102, 0.15);
            border-color: rgba(255, 0, 102, 0.4);
        }

        .param-status {
            font-size: 18px;
            margin-left: 10px;
        }

        .hint-tip:before {
            content: "üí° ";
            font-weight: bold;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        /* INTRO OVERLAY STYLES */
        .intro-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.97);
            z-index: 3000;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            opacity: 1;
            transition: opacity 1s ease;
        }

        .intro-overlay.hiding {
            opacity: 0;
            pointer-events: none;
        }


        .intro-content {
            max-width: 700px;
            padding: 40px;
            border: 3px solid var(--primary-color);
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.5);
        }
        
        #intro-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.3;
        }

        .intro-title {
            font-size: 48px;
            color: var(--primary-color);
            margin-bottom: 20px;
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
            animation: glitch 5s infinite;
        }

        .intro-subtitle {
            font-size: 24px;
            color: var(--text-color);
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .intro-text {
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 30px;
            opacity: 0.9;
        }

        .intro-question {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;            color: var(--text-color);
        }

        .intro-answers {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }

        .intro-answer {
            padding: 15px;
            border: 2px solid rgba(0, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.3s;
        }

        .intro-answer:hover {
            background: rgba(0, 255, 255, 0.2);
            border-color: var(--primary-color);
        }

        .intro-answer.correct {
            background: rgba(0, 255, 102, 0.3);
            border-color: var(--success-color);
            box-shadow: 0 0 20px rgba(0, 255, 102, 0.6);
        }

        .intro-feedback {
            color: var(--secondary-color);
            min-height: 20px;
            margin-top: 15px;
            font-weight: bold;
        }

        /* ABIOGENESIS OVERLAY STYLES */
        .abiogenesis-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 4000;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 2s ease-in-out;
        }

        .abiogenesis-overlay.show {
            opacity: 1;
        }

        .abiogenesis-title {
            font-size: 48px;
            color: var(--primary-color);
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.9);
            animation: pulse 4s infinite ease-in-out;
        }

        @keyframes glitch {
            0%, 100% { text-shadow: 0 0 15px rgba(0, 255, 255, 0.7), 0 0 5px #0FF; transform: none; }
            5% { transform: skew(-0.5deg, -0.2deg); }
            10% { transform: none; }
            15% { transform: skew(0.5deg, 0.2deg); }
            20% { transform: none; }
            49% { text-shadow: 0 0 15px rgba(0, 255, 255, 0.7), 0 0 5px #0FF; }
            50% { text-shadow: 0 0 15px rgba(255, 0, 102, 0.7), 0 0 5px #F06; transform: translateX(-2px); }
            51% { text-shadow: 0 0 15px rgba(0, 255, 255, 0.7), 0 0 5px #0FF; transform: translateX(2px); }
            52% { transform: none; }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
        }
    </style>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="level-indicator">
        <div class="level-title">ATOMICFORGE - Level 0</div>
        <div class="level-progress">
            <div class="level-progress-bar" id="level-progress"></div>
        </div>
    </div>

    <div class="element-key" id="element-key">
        <h3 onclick="toggleElementKey()">
            Elements
            <span class="toggle-icon" id="element-toggle">[-]</span>
        </h3>
        <div class="key-content">
            <div class="element-item">
                <div class="element-color" style="background: #0FF;"></div>
                <span>Hydrogen (H)</span>
            </div>
            <div class="element-item">
                <div class="element-color" style="background: #FFF;"></div>
                <span>Carbon (C)</span>
            </div>
            <div class="element-item">
                <div class="element-color" style="background: #F06;"></div>
                <span>Oxygen (O)</span>
            </div>
            <div class="element-item">
                <div class="element-color" style="background: #0F6;"></div>
                <span>Nitrogen (N)</span>
            </div>
        </div>
    </div>

    <div class="molecule-list" id="molecule-list">
        <h3 onclick="toggleMoleculeList()">
            Molecules
            <span class="toggle-icon" id="molecule-toggle">[-]</span>
        </h3>
        <div class="list-content">
            <div id="molecule-types">
                <em style="opacity: 0.5;">None yet...</em>
            </div>
        </div>
    </div>

    <div class="achievements-panel" id="achievements-panel">
        <h3 onclick="toggleAchievements()">
            Achievements
            <span class="toggle-icon" id="achievements-toggle">[-]</span>
        </h3>
        <div class="achievements-content">
            <div class="achievements-summary">
                <div class="summary-text" id="achievement-count">0 / 15 Unlocked</div>
                <div class="summary-progress" id="achievement-percent">0%</div>
            </div>
            <div id="achievements-list"></div>
        </div>
    </div>

    <!-- ACHIEVEMENT HELP PANEL -->
    <div class="achievement-help" id="achievement-help">
        <div class="help-header">
            <div class="help-icon" id="achievement-help-icon">‚öõÔ∏è</div>
            <div>
                <div class="help-title" id="achievement-help-title">Achievement Help</div>
                <div class="help-xp" id="achievement-help-xp">+0 XP</div>
            </div>
        </div>

        
        <div class="help-section">
            <h3>Description</h3>
            <p id="achievement-help-description">Description will appear here.</p>
        </div>

        <div class="help-section" id="current-progress-section">
            <h3>Current Progress</h3>
            <div class="current-progress">
                <div class="progress-info" id="achievement-help-progress-info">Not started</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="help-progress-bar" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <div class="help-section" id="strategy-section">
            <h3>Strategy & Tips</h3>
            <ul class="strategy-list" id="achievement-help-strategy-list">
                <li>Strategy tips will appear here</li>
            </ul>
        </div>

        <div class="help-section" id="parameters-section">
            <h3>Recommended Parameters</h3>
            <div class="parameter-recommendations" id="achievement-help-parameters">
                <!-- Parameter recommendations will be inserted here -->
            </div>
        </div>

        <div class="help-section" id="formula-section">
            <h3>Molecular Formula</h3>
            <div class="molecule-formula" id="achievement-help-formula">
                Formula will appear here
            </div>
        </div>

        <div class="hint-tip" id="achievement-help-hint">
            Pro tip: Adjust parameters gradually and observe the results!
        </div>

        <button class="close-help" onclick="closeHelp()">CLOSE</button>
    </div>

    <div class="intro-overlay" id="intro-overlay">
        <canvas id="intro-canvas"></canvas>
        <div class="intro-content">
            <h1 class="intro-title">COSMIC DRIVE</h1>
            <p class="intro-subtitle">ATOMICFORGE</p>
            <p class="intro-text">
                This is a simulation about **emergence** ‚Äî the phenomenon where complex results arise from simple rules.
                You are not in direct control. Your role is to be a scientist: observe, form a hypothesis, adjust the environment, and discover what emerges.
            </p>
            <p class="intro-question">What is the core principle of this simulation?</p>
            <div class="intro-answers">
                <div class="intro-answer" onclick="checkIntroAnswer('control')">Directly controlling every particle to build structures.</div>
                <div class="intro-answer" onclick="checkIntroAnswer('recipe')">Following a strict recipe to achieve a single "win" condition.</div>
                <div class="intro-answer" onclick="checkIntroAnswer('emergence')">Guiding simple rules to see what complex patterns emerge.</div>
                <div class="intro-answer" onclick="checkIntroAnswer('speed')">Achieving the highest score as quickly as possible.</div>
            </div>
            <div class="intro-feedback" id="intro-feedback">
                &nbsp;
            </div>
        </div>
    </div>

    <div class="abiogenesis-overlay" id="abiogenesis-overlay">
        <div class="abiogenesis-title" id="abiogenesis-title"></div>
    </div>

    <div class="achievement-popup" id="achievement-popup">
        <div class="achievement-popup-icon" id="popup-icon">üèÜ</div>
        <div class="achievement-popup-title" id="popup-title">Achievement Unlocked!</div>
        <div class="achievement-popup-subtitle" id="popup-subtitle">First Molecule</div>
        <div class="achievement-popup-desc" id="popup-desc">You've created your first molecule!</div>
        <div class="achievement-popup-xp" id="popup-xp">+50 XP</div>
    </div>

    <div class="level-up-popup" id="level-up-popup">
        <div class="level-up-title" id="level-up-title">LEVEL UP!</div>
        <div class="level-up-subtitle" id="level-up-subtitle">You've reached Level 1!</div>
        <div class="level-up-unlocks" id="level-up-unlocks">
            <strong>New Unlock:</strong> Oxygen Particles
        </div>
    </div>

    <canvas id="canvas"></canvas>
    
    <div class="tutorial" id="tutorial">
        <div class="tutorial-text">
            In the beginning, there was chaos...<br>
            Particles collide in the primordial void.
        </div>
        <div class="tutorial-hint">
            Adjust temperature (45-55) to see molecules form<br>
            <br>
            <strong>Keyboard Shortcuts:</strong><br>
            Space/P = Pause | Ctrl+R = Reset<br>
            Ctrl+S = Export Data | Ctrl+I = Save Image<br>
            E = Elements | M = Molecules | A = Achievements<br>
            H = Achievement Help (when viewing achievements)
        </div>
        <button onclick="closeTutorial()">BEGIN</button>
    </div>

    <div class="achievement" id="achievement">
        <div class="achievement-title">‚öõÔ∏è FIRST MOLECULE</div>
        <div class="achievement-subtitle">Molecular Architect</div>
        <div class="achievement-desc" id="achievement-desc">
            From chaos, order emerges.<br>
            You have formed your first stable molecule.
        </div>
    </div>

    <div class="controls">
        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot" id="status-dot"></div>
                <span id="status-text">RUNNING</span>
            </div>
            <div class="timer" id="timer">00:00:00</div>
        </div>

        <div class="button-group">
            <button id="pause-btn" onclick="togglePause()">‚è∏ PAUSE</button>
            <button id="reset-btn" class="danger" onclick="resetSimulation()">‚Üª RESET</button>
            <button id="export-btn" class="success" onclick="exportData()">üíæ EXPORT DATA</button>
            <button id="focus-toggle-btn" onclick="toggleFocusMode()">üî¨ FOCUS: OFF</button>
            <button id="export-img-btn" class="success" onclick="exportImage()">üì∑ SAVE IMAGE</button>
        </div>

        <div id="protoforge-controls">
            <div class="control-group">
                <label>
                    <span>üå°Ô∏è Nutrient Temp</span>
                    <input type="range" id="proto-temperature" min="0" max="100" value="50">
                    <span class="value" id="proto-temp-value">50</span>
                </label>
            </div>
            <div class="control-group">
                <label>
                    <span>‚ö°Ô∏è Energy Flux</span>
                    <input type="range" id="proto-energy" min="0" max="100" value="20">
                    <span class="value" id="proto-energy-value">20</span>
                </label>
            </div>
        </div>

        <div class="protoforge-status" id="protoforge-status">
            <h3>Proto-Cell Status</h3>
        </div>
        
        <div class="control-group">
            <label>
                <span>üå°Ô∏è Temperature</span>
                <input type="range" id="temperature" min="0" max="100" value="50">
                <span class="value" id="temp-value">50</span>
            </label>
        </div>
        
        <div class="control-group">
            <label>
                <span>üåä Particle Density</span>
                <input type="range" id="density" min="50" max="500" value="150">
                <span class="value" id="density-value">150</span>
            </label>
        </div>
        
        <div class="control-group">
            <label>
                <span>‚ö° Energy Input</span>
                <input type="range" id="energy" min="0" max="100" value="20">
                <span class="value" id="energy-value">20</span>
            </label>
        </div>

        <div class="stats">
            <div class="stat">
                <div class="stat-label">Particles</div>
                <div class="stat-value" id="particle-count">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Molecules</div>
                <div class="stat-value" id="molecule-count">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Unique Types</div>
                <div class="stat-value" id="unique-molecules">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Collisions</div>
                <div class="stat-value" id="collision-count">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Avg Energy</div>
                <div class="stat-value" id="avg-energy">0</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        
        function resizeCanvas() {
            const controls = document.querySelector('.controls');
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight - controls.offsetHeight;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Particle types
        const ELEMENT_TYPES = {
            HYDROGEN: { symbol: 'H', color: '#0FF', size: 2, mass: 1.0, electrons: 1 },
            CARBON: { symbol: 'C', color: '#FFF', size: 3, mass: 12.0, electrons: 4 },
            OXYGEN: { symbol: 'O', color: '#F06', size: 3, mass: 16.0, electrons: 6 },
            NITROGEN: { symbol: 'N', color: '#0F6', size: 3, mass: 14.0, electrons: 5 }
        };

        // Particle system
        class Particle {
            constructor(x, y, type = ELEMENT_TYPES.HYDROGEN) {
                this.id = particleIdCounter++;
                this.x = x || Math.random() * width;
                this.y = y || Math.random() * height;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.type = type;
                this.size = type.size;
                this.mass = type.mass;
                this.energy = Math.random() * 10;
                this.bonded = false;
                this.molecule = null;
                this.trail = [];
                this.maxTrail = 10;
            }

            update(temperature, energyInput) {
                if (this.bonded && this.molecule) {
                    // Orbit around molecule center
                    const angle = (Date.now() / 1000 + this.orbitalOffset) * this.orbitalSpeed;
                    const radius = this.orbitalRadius;
                    this.x = this.molecule.x + Math.cos(angle) * radius;
                    this.y = this.molecule.y + Math.sin(angle) * radius;
                    return;
                }

                // Temperature affects velocity
                const tempFactor = temperature / 50;
                
                // Brownian motion
                this.vx += (Math.random() - 0.5) * 0.5 * tempFactor;
                this.vy += (Math.random() - 0.5) * 0.5 * tempFactor;
                
                // Energy input adds random kicks
                if (Math.random() < energyInput / 1000) {
                    this.vx += (Math.random() - 0.5) * 5;
                    this.vy += (Math.random() - 0.5) * 5;
                }
                
                // Damping
                this.vx *= 0.99;
                this.vy *= 0.99;
                
                // Max velocity based on temperature
                const maxVel = 2 + tempFactor * 3;
                const vel = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (vel > maxVel) {
                    this.vx = (this.vx / vel) * maxVel;
                    this.vy = (this.vy / vel) * maxVel;
                }
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Wrap around edges
                if (this.x < 0) this.x = width;
                if (this.x > width) this.x = 0;
                if (this.y < 0) this.y = height;
                if (this.y > height) this.y = 0;
                
                // Update trail
                this.trail.push({x: this.x, y: this.y});
                if (this.trail.length > this.maxTrail) {
                    this.trail.shift();
                }
                
                // Update energy based on velocity
                this.energy = vel * 2;
            }

            draw() {
                // Draw trail
                if (this.trail.length > 1 && !this.bonded) {
                    ctx.strokeStyle = `rgba(255, 255, 255, 0.1)`;
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for (let i = 1; i < this.trail.length; i++) {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    ctx.stroke();
                }

                // Draw particle
                if (this.bonded) {
                    // Bonded atoms glow - use rgba for proper color handling
                    const rgb = this.hexToRgb(this.type.color);
                    
                    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 3);
                    gradient.addColorStop(0, this.type.color);
                    gradient.addColorStop(0.5, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.5)`);
                    gradient.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0)`);
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw core
                    ctx.fillStyle = this.type.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Free particles
                    ctx.fillStyle = this.type.color;
                    ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
                }
            }

            hexToRgb(hex) {
                // Convert hex to RGB
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : {r: 255, g: 255, b: 255};
            }
        }

        // Molecule class
        class Molecule {
            constructor(particles) {
                this.particles = particles;
                this.x = particles.reduce((sum, p) => sum + p.x, 0) / particles.length;
                this.y = particles.reduce((sum, p) => sum + p.y, 0) / particles.length;
                this.formed = Date.now();
                this.stable = true;
                
                // Proto-cell properties
                this.energy = 100;
                this.integrity = 100;
                this.replications = 0;

                // Determine molecule type
                this.type = this.getMoleculeType();
                this.name = this.getMoleculeName();
                
                // Mark particles as bonded and set orbital positions
                particles.forEach((p, i) => {
                    p.bonded = true;
                    p.molecule = this;
                    p.orbitalRadius = 15 + Math.random() * 10;
                    p.orbitalSpeed = 0.5 + Math.random() * 0.5;
                    p.orbitalOffset = (i / particles.length) * Math.PI * 2;
                    p.x = this.x;
                    p.y = this.y;
                });
            }

            getMoleculeType() {
                const formula = this.particles
                    .map(p => p.type.symbol)
                    .sort()
                    .join('');
                
                return formula;
            }

            getMoleculeName() {
                const types = {
                    'HH': 'H‚ÇÇ (Hydrogen)',
                    'HO': 'OH (Hydroxyl)',
                    'HHO': 'H‚ÇÇO (Water)',
                    'CC': 'C‚ÇÇ (Dicarbon)',
                    'CO': 'CO (Carbon Monoxide)',
                    'CCO': 'C‚ÇÇO',
                    'COO': 'CO‚ÇÇ (Carbon Dioxide)',
                    'NN': 'N‚ÇÇ (Nitrogen)',
                    'HN': 'NH',
                    'HHN': 'NH‚ÇÇ',
                    'HHHN': 'NH‚ÇÉ (Ammonia)',
                    'CN': 'CN (Cyanide)',
                    'CHN': 'HCN',
                    'NO': 'NO (Nitric Oxide)',
                    'NNO': 'N‚ÇÇO',
                    'NOO': 'NO‚ÇÇ',
                    'C2H5NO2': 'Glycine (Amino Acid)',
                    'C3H6O2': 'Lipid Precursor'
                };
                
                return types[this.type] || this.type;
            }

            draw() {
                const age = Date.now() - this.formed;
                const pulseScale = 1 + Math.sin(age / 300) * 0.15;
                
                // Draw glow around molecule
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, 40 * pulseScale);
                gradient.addColorStop(0, 'rgba(0, 255, 255, 0.4)');
                gradient.addColorStop(0.5, 'rgba(0, 255, 255, 0.2)');
                gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 40 * pulseScale, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw bonds between particles
                ctx.strokeStyle = '#0FF';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.6;
                for (let i = 0; i < this.particles.length; i++) {
                    for (let j = i + 1; j < this.particles.length; j++) {
                        ctx.beginPath();
                        ctx.moveTo(this.particles[i].x, this.particles[i].y);
                        ctx.lineTo(this.particles[j].x, this.particles[j].y);
                        ctx.stroke();
                    }
                }
                ctx.globalAlpha = 1;
                
                // Draw molecule formula label
                ctx.fillStyle = '#0FF';
                ctx.font = 'bold 14px "Courier New"';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(0, 255, 255, 0.8)';
                ctx.shadowBlur = 10;
                ctx.fillText(this.type, this.x, this.y - 35);
                ctx.shadowBlur = 0;
            }
        }

        // A more robust SpatialHash class
        class SpatialHash {
            constructor(cellSize) {
                this.cellSize = cellSize;
                this.grid = new Map();
            }

            getKey(x, y) {
                const cellX = Math.floor(x / this.cellSize);
                const cellY = Math.floor(y / this.cellSize);
                return `${cellX},${cellY}`;
            }

            clear() {
                this.grid.clear();
            }

            insert(particle) {
                const key = this.getKey(particle.x, particle.y);
                if (!this.grid.has(key)) {
                    this.grid.set(key, []);
                }
                this.grid.get(key).push(particle);
            }

            getNearby(particle) {
                const nearby = new Set();
                const cellX = Math.floor(particle.x / this.cellSize);
                const cellY = Math.floor(particle.y / this.cellSize);

                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const key = `${cellX + i},${cellY + j}`;
                        if (this.grid.has(key)) {
                            for (const p of this.grid.get(key)) {
                                nearby.add(p);
                            }
                        }
                    }
                }
                return nearby;
            }
        }

        // Game state
        let particles = [];
        let molecules = [];
        let moleculeTypes = new Map(); // Track unique molecule types
        let collisionCount = 0;
        let firstMoleculeFormed = false;
        let isPaused = true;
        let startTime = Date.now();
        let elapsedTime = 0;
        let pauseStartTime = 0;
        let animationId = null;
        let totalXP = 0;
        let currentLevel = 0;
        let abiogenesisTriggered = false;
        let thermoTimeInRange = 0;
        let abiogenesisFocus = false;
        let abiogenesisFocusTarget = null;
        let camera = {
            x: width / 2,
            y: height / 2,
            zoom: 1.0,
            targetX: width / 2,
            targetY: height / 2,
            targetZoom: 1.0,
            lerpFactor: 0.02
        };
        let focusOnNewMolecules = false;
        let focusTarget = null;
        let currentHelpAchievementId = null;

        const GameState = {
            INTRO: 'INTRO',
            ATOMICFORGE: 'ATOMICFORGE',
            PROTOFORGE: 'PROTOFORGE',
            LIFEFORGE: 'LIFEFORGE'
        };
        let currentGameState = GameState.INTRO;
        let protoCell = null;

        let particleIdCounter = 0;

        const spatialHash = new SpatialHash(50); // Cell size of 50px

        // Achievement system
        const ACHIEVEMENTS = {
            first_molecule: {
                id: 'first_molecule',
                icon: '‚öõÔ∏è',
                title: 'First Molecule',
                description: 'Form your first stable molecule',
                xp: 50,
                unlocked: false,
                check: () => molecules.length >= 1
            },
            hydrogen_factory: {
                id: 'hydrogen_factory',
                icon: 'üí®',
                title: 'Hydrogen Factory',
                description: 'Create 5 H‚ÇÇ molecules',
                xp: 100,
                unlocked: false,
                check: () => (moleculeTypes.get('H‚ÇÇ (Hydrogen)') || 0) >= 5,
                progress: () => Math.min(100, ((moleculeTypes.get('H‚ÇÇ (Hydrogen)') || 0) / 5) * 100)
            },
            water_of_life: {
                id: 'water_of_life',
                icon: 'üíß',
                title: 'Water of Life',
                description: 'Successfully create H‚ÇÇO (water)',
                xp: 150,
                unlocked: false,
                check: () => moleculeTypes.has('H‚ÇÇO (Water)')
            },
            radical_creator: {
                id: 'radical_creator',
                icon: '‚ö°',
                title: 'Radical Creator',
                description: 'Form an OH hydroxyl radical',
                xp: 100,
                unlocked: false,
                check: () => moleculeTypes.has('OH (Hydroxyl)')
            },
            toxic_chemist: {
                id: 'toxic_chemist',
                icon: '‚ò†Ô∏è',
                title: 'Toxic Chemist',
                description: 'Create CN cyanide',
                xp: 125,
                unlocked: false,
                check: () => moleculeTypes.has('CN (Cyanide)')
            },
            ammonia_maker: {
                id: 'ammonia_maker',
                icon: 'üß™',
                title: 'Ammonia Maker',
                description: 'Synthesize NH‚ÇÉ (ammonia)',
                xp: 150,
                unlocked: false,
                check: () => moleculeTypes.has('NH‚ÇÉ (Ammonia)')
            },
            molecular_diversity: {
                id: 'molecular_diversity',
                icon: 'üåà',
                title: 'Molecular Diversity',
                description: 'Create 5 different molecule types',
                xp: 250,
                unlocked: false,
                check: () => moleculeTypes.size >= 5,
                progress: () => Math.min(100, (moleculeTypes.size / 5) * 100)
            },
            speed_demon: {
                id: 'speed_demon',
                icon: 'üî•',
                title: 'Speed Demon',
                description: 'Reach 50,000 collisions',
                xp: 100,
                unlocked: false,
                check: () => collisionCount >= 50000,
                progress: () => Math.min(100, (collisionCount / 50000) * 100)
            },
            molecular_factory: {
                id: 'molecular_factory',
                icon: 'üè≠',
                title: 'Molecular Factory',
                description: 'Form 20 molecules total',
                xp: 200,
                unlocked: false,
                check: () => molecules.length >= 20,
                progress: () => Math.min(100, (molecules.length / 20) * 100)
            },
            thermodynamist: {
                id: 'thermodynamist',
                icon: 'üå°Ô∏è',
                title: 'Thermodynamist',
                description: 'Find the perfect temperature (45-55) and hold for 30s',
                xp: 100,
                unlocked: false,
                check: () => thermoTimeInRange >= 30000, // 30 seconds in ms
                progress: () => {
                    const progress = Math.min(100, (thermoTimeInRange / 30000) * 100);
                    return progress;
                }
            },
            patient_chemist: {
                id: 'patient_chemist',
                icon: '‚è±Ô∏è',
                title: 'Patient Chemist',
                description: 'Run simulation for 5 minutes',
                xp: 75,
                unlocked: false,
                check: () => getElapsedTime() >= 300000,
                progress: () => Math.min(100, (getElapsedTime() / 300000) * 100)
            },
            carbon_dioxide: {
                id: 'carbon_dioxide',
                icon: 'ü´ß',
                title: 'Carbon Dioxide',
                description: 'Create CO‚ÇÇ',
                xp: 125,
                unlocked: false,
                check: () => moleculeTypes.has('CO‚ÇÇ (Carbon Dioxide)')
            },
            nitrogen_gas: {
                id: 'nitrogen_gas',
                icon: 'üí®',
                title: 'Nitrogen Gas',
                description: 'Form N‚ÇÇ',
                xp: 100,
                unlocked: false,
                check: () => moleculeTypes.has('N‚ÇÇ (Nitrogen)')
            },
            abiogenesis: {
                id: 'abiogenesis',
                icon: 'üå±',
                title: 'Abiogenesis',
                description: 'Witness the emergence of the first proto-cell',
                xp: 500,
                unlocked: false,
                check: () => abiogenesisTriggered
            },
            prebiotic_soup: {
                id: 'prebiotic_soup',
                icon: 'üß¨',
                title: 'Prebiotic Soup',
                description: 'Create H‚ÇÇO, NH‚ÇÉ, and HCN (building blocks of life)',
                xp: 300,
                unlocked: false,
                check: () => moleculeTypes.has('H‚ÇÇO (Water)') &&
                           moleculeTypes.has('NH‚ÇÉ (Ammonia)') &&
                           moleculeTypes.has('HCN')
            },
            master_chemist: {
                id: 'master_chemist',
                icon: 'üë®‚Äçüî¨',
                title: 'Master Chemist',
                description: 'Unlock all other achievements',
                xp: 500,
                unlocked: false,
                check: () => {
                    const others = Object.keys(ACHIEVEMENTS).filter(id => id !== 'master_chemist');
                    return others.every(id => ACHIEVEMENTS[id].unlocked);
                }
            }
        };

        // Achievement help data
        const ACHIEVEMENT_HELP = {
            first_molecule: {
                description: "Form your first stable molecule from colliding particles.",
                strategy: [
                    "Start with moderate temperature (45-55¬∞K)",
                    "Keep energy input around 20-30 for stable conditions",
                    "Higher density increases collision chances",
                    "Be patient - first molecule usually forms within 30 seconds"
                ],
                parameters: {
                    temperature: "45-55¬∞K",
                    density: "150-250",
                    energy: "20-30"
                },
                formula: "Any two-element combination"
            },
            hydrogen_factory: {
                description: "Create 5 H‚ÇÇ (hydrogen) molecules - the most abundant molecule in the universe.",
                strategy: [
                    "Focus on hydrogen-hydrogen collisions",
                    "Moderate temperatures work best (40-60¬∞K)",
                    "Higher hydrogen concentration helps",
                    "H‚ÇÇ forms easily under most conditions"
                ],
                parameters: {
                    temperature: "40-60¬∞K",
                    density: "200+",
                    energy: "15-35"
                },
                formula: "H + H ‚Üí H‚ÇÇ"
            },
            water_of_life: {
                description: "Successfully create H‚ÇÇO (water) - the essential molecule for life.",
                strategy: [
                    "Need both hydrogen and oxygen particles",
                    "Optimal temperature: 50-65¬∞K",
                    "Balance element ratios (2:1 H:O ideal)",
                    "Watch for H + O ‚Üí OH first, then OH + H ‚Üí H‚ÇÇO"
                ],
                parameters: {
                    temperature: "50-65¬∞K",
                    density: "200-300",
                    energy: "25-40"
                },
                formula: "2H + O ‚Üí H‚ÇÇO"
            },
            radical_creator: {
                description: "Form an OH hydroxyl radical - a highly reactive molecule important in chemistry.",
                strategy: [
                    "Hydrogen and oxygen collisions",
                    "Slightly higher temperatures help (55-70¬∞K)",
                    "Moderate energy input (25-45)",
                    "OH often forms before H‚ÇÇO"
                ],
                parameters: {
                    temperature: "55-70¬∞K",
                    density: "150-250",
                    energy: "25-45"
                },
                formula: "H + O ‚Üí OH"
            },
            toxic_chemist: {
                description: "Create CN cyanide - a simple but toxic organic molecule.",
                strategy: [
                    "Carbon and nitrogen collisions required",
                    "Moderate temperatures (45-65¬∞K)",
                    "Both elements needed in simulation",
                    "Can be rare depending on element distribution"
                ],
                hint: "Creating Cyanide (CN) is a step towards Hydrogen Cyanide (HCN), a key component for prebiotic soup.",
                parameters: {
                    temperature: "45-65¬∞K",
                    density: "200-300",
                    energy: "20-40"
                },
                formula: "C + N ‚Üí CN"
            },
            ammonia_maker: {
                description: "Synthesize NH‚ÇÉ (ammonia) - important for fertilizers and prebiotic chemistry.",
                strategy: [
                    "Requires nitrogen and hydrogen",
                    "Optimal ratio: 1N:3H",
                    "Moderate temperatures (50-70¬∞K)",
                    "Forms through intermediate steps (NH ‚Üí NH‚ÇÇ ‚Üí NH‚ÇÉ)"
                ],
                parameters: {
                    temperature: "50-70¬∞K",
                    density: "250-350",
                    energy: "30-50"
                },
                formula: "N + 3H ‚Üí NH‚ÇÉ"
            },
            molecular_diversity: {
                description: "Create 5 different molecule types - demonstrating chemical variety.",
                strategy: [
                    "Ensure all element types are present",
                    "Experiment with different temperatures",
                    "Higher density increases variety chances",
                    "Track progress in Molecules panel"
                ],
                parameters: {
                    temperature: "Vary 40-70¬∞K",
                    density: "250+",
                    energy: "25-45"
                },
                formula: "Multiple combinations"
            },
            speed_demon: {
                description: "Reach 50,000 particle collisions - mastering high-energy conditions.",
                strategy: [
                    "High density increases collision rate",
                    "Higher temperatures increase particle speed",
                    "More energy input creates more activity",
                    "Be patient - this takes time to accumulate"
                ],
                parameters: {
                    temperature: "60-80¬∞K",
                    density: "300+",
                    energy: "40-60"
                },
                formula: "Accumulated collisions"
            },
            molecular_factory: {
                description: "Form 20 molecules total - becoming a proficient molecular architect.",
                strategy: [
                    "Stable conditions help accumulation",
                    "Moderate parameters work best",
                    "Avoid extreme temperatures that break bonds",
                    "Higher density speeds up production"
                ],
                parameters: {
                    temperature: "45-65¬∞K",
                    density: "200-300",
                    energy: "20-40"
                },
                formula: "Cumulative production"
            },
            thermodynamist: {
                description: "Find the perfect temperature (45-55¬∞K) and maintain it for 30 seconds.",
                strategy: [
                    "Use temperature slider carefully",
                    "Watch for optimal bonding conditions",
                    "Avoid sudden changes",
                    "Monitor molecule formation rate"
                ],
                parameters: {
                    temperature: "45-55¬∞K",
                    density: "Any",
                    energy: "Any"
                },
                formula: "Temperature stability"
            },
            patient_chemist: {
                description: "Run simulation for 5 minutes - good science takes time!",
                strategy: [
                    "Let the simulation run continuously",
                    "Observe long-term patterns",
                    "Make gradual parameter adjustments",
                    "Watch the evolution of molecular complexity"
                ],
                parameters: {
                    temperature: "Any",
                    density: "Any",
                    energy: "Any"
                },
                formula: "Time accumulation"
            },
            carbon_dioxide: {
                description: "Create CO‚ÇÇ - essential for plant life and a key greenhouse gas.",
                strategy: [
                    "Carbon and oxygen collisions",
                    "Higher temperatures help (60-75¬∞K)",
                    "Often forms via CO intermediate",
                    "Watch for C + O‚ÇÇ ‚Üí CO‚ÇÇ or C + 2O ‚Üí CO‚ÇÇ"
                ],
                parameters: {
                    temperature: "60-75¬∞K",
                    density: "200-300",
                    energy: "30-50"
                },
                formula: "C + O‚ÇÇ ‚Üí CO‚ÇÇ or C + 2O ‚Üí CO‚ÇÇ"
            },
            nitrogen_gas: {
                description: "Form N‚ÇÇ - making up 78% of Earth's atmosphere.",
                strategy: [
                    "Nitrogen-nitrogen collisions",
                    "Moderate conditions work well",
                    "Very stable once formed",
                    "Common in nitrogen-rich environments"
                ],
                parameters: {
                    temperature: "40-65¬∞K",
                    density: "200-300",
                    energy: "20-40"
                },
                formula: "N + N ‚Üí N‚ÇÇ"
            },
            prebiotic_soup: {
                description: "Create H‚ÇÇO, NH‚ÇÉ, and HCN - the building blocks of life.",
                strategy: [
                    "Most challenging achievement!",
                    "Need all element types present",
                    "Balance parameters carefully",
                    "Try creating H‚ÇÇO and NH‚ÇÉ first in the 50-70¬∞K range.",
                    "HCN (Hydrogen Cyanide) often requires slightly higher energy. Try creating CN (Cyanide) first, then see if it bonds with Hydrogen.",
                    "Focus on one molecule at a time"
                ],
                parameters: {
                    temperature: "50-70¬∞K",
                    density: "250-350",
                    energy: "30-50"
                },
                formula: "H‚ÇÇO + NH‚ÇÉ + HCN"
            },
            master_chemist: {
                description: "Unlock all other achievements - becoming a true molecular master.",
                strategy: [
                    "Systematically work through each achievement",
                    "Use the help information for each one",
                    "Track your progress in this panel",
                    "Experiment and learn from each simulation",
                    "Patience and observation are key"
                ],
                parameters: {
                    temperature: "All ranges",
                    density: "All ranges",
                    energy: "All ranges"
                },
                formula: "Complete all challenges"
            }
        };

        const LEVEL_DEFINITIONS = [
            { // Level 0
                name: "Particle Soup",
                goal: "Form your first molecule.",
                xp_reward: 100,
                unlocks: "Oxygen particles become available.",
                checkCompletion: () => molecules.length >= 1,
                getProgress: () => {
                    if (molecules.length > 0) return 100;
                    return Math.min(99, (collisionCount / 1000) * 100);
                }
            },
            { // Level 1
                name: "Molecular Weaver",
                goal: "Create H‚ÇÇO (Water).",
                xp_reward: 150,
                unlocks: "Carbon and Nitrogen particles become available.",
                checkCompletion: () => moleculeTypes.has('H‚ÇÇO (Water)'),
                getProgress: () => {
                    const totalMoleculesNeeded = 10;
                    const waterProgress = moleculeTypes.has('H‚ÇÇO (Water)') ? 50 : 0;
                    const moleculeCountProgress = Math.min(50, (molecules.length / totalMoleculesNeeded) * 50);
                    return waterProgress + moleculeCountProgress;
                }
            },
            { // Level 2
                name: "Prebiotic Soup",
                goal: "Create the building blocks of life: H‚ÇÇO, NH‚ÇÉ, and HCN.",
                xp_reward: 300,
                unlocks: "Higher bonding complexity.",
                checkCompletion: () => moleculeTypes.has('H‚ÇÇO (Water)') && moleculeTypes.has('NH‚ÇÉ (Ammonia)') && moleculeTypes.has('HCN'),
                getProgress: () => {
                    let progress = 0;
                    if (moleculeTypes.has('H‚ÇÇO (Water)')) progress += 33;
                    if (moleculeTypes.has('NH‚ÇÉ (Ammonia)')) progress += 33;
                    if (moleculeTypes.has('HCN')) progress += 33;
                    return progress;
                }
            },
            { // Level 3
                name: "Life Seeder",
                goal: "Witness the miracle of abiogenesis.",
                xp_reward: 1000,
                unlocks: "LifeForge and the next era of evolution!",
                checkCompletion: () => abiogenesisTriggered,
                getProgress: () => {
                    let progress = (moleculeTypes.has('Glycine (Amino Acid)') ? 50 : 0) + (moleculeTypes.has('Lipid Precursor') ? 50 : 0);
                    return progress;
                }
            }
        ];

        let achievementsUnlocked = new Set();

        // History tracking for export
        let simulationHistory = {
            startTime: new Date().toISOString(),
            events: [],
            snapshots: [],
            achievements: []
        };

        // Controls
        let temperature = 50;
        let density = 150;
        let energyInput = 20;

        document.getElementById('temperature').addEventListener('input', (e) => {
            temperature = parseInt(e.target.value);
            document.getElementById('temp-value').textContent = temperature;
            
            simulationHistory.events.push({
                time: getElapsedTime(),
                type: 'parameter_change',
                parameter: 'temperature',
                value: temperature
            });
        });
        document.getElementById('proto-temperature').addEventListener('input', (e) => { if(protoCell) protoCell.temperature = parseInt(e.target.value); document.getElementById('proto-temp-value').textContent = e.target.value; });
        document.getElementById('temperature').addEventListener('input', updateRealTimeHelp);

        document.getElementById('density').addEventListener('input', (e) => {
            density = parseInt(e.target.value);
            document.getElementById('density-value').textContent = density;
            adjustParticleCount();
            
            simulationHistory.events.push({
                time: getElapsedTime(),
                type: 'parameter_change',
                parameter: 'density',
                value: density
            });
        });
        document.getElementById('proto-energy').addEventListener('input', (e) => { if(protoCell) protoCell.energyFlux = parseInt(e.target.value); document.getElementById('proto-energy-value').textContent = e.target.value; });
        document.getElementById('density').addEventListener('input', updateRealTimeHelp);

        document.getElementById('energy').addEventListener('input', (e) => {
            energyInput = parseInt(e.target.value);
            document.getElementById('energy-value').textContent = energyInput;
            
            simulationHistory.events.push({
                time: getElapsedTime(),
                type: 'parameter_change',
                parameter: 'energy',
                value: energyInput
            });
        });
        document.getElementById('energy').addEventListener('input', updateRealTimeHelp);

        function adjustParticleCount() {
            const numToAdd = density - particles.length;
            if (numToAdd > 0) {
                for (let i = 0; i < numToAdd; i++) { // Weighted distribution based on level
                    const rand = Math.random();
                    let type = ELEMENT_TYPES.HYDROGEN; // Default

                    if (currentLevel === 1) { // H, O
                        if (rand > 0.7) type = ELEMENT_TYPES.OXYGEN;
                    } else if (currentLevel >= 2) { // H, O, C, N
                        if (rand < 0.70) type = ELEMENT_TYPES.HYDROGEN;
                        else if (rand < 0.85) type = ELEMENT_TYPES.CARBON;
                        else if (rand < 0.95) type = ELEMENT_TYPES.OXYGEN;
                        else type = ELEMENT_TYPES.NITROGEN;
                    }
                    particles.push(new Particle(null, null, type));
                }
            } else if (numToAdd < 0) {
                const numToRemove = -numToAdd;
                // Remove free particles only
                particles = particles.filter(p => p.bonded || Math.random() > numToRemove / particles.filter(p => !p.bonded).length);
                particles.splice(density);
            }
        }

        function closeTutorial() {
            document.getElementById('tutorial').style.display = 'none';
            if (isPaused) {
                togglePause(); // Start the simulation
                startTime = Date.now(); // Reset timer to start from 00:00:00
            }
        }

        function checkIntroAnswer(answer) {
            const feedbackEl = document.getElementById('intro-feedback');
            if (answer === 'emergence') {
                document.querySelector('.intro-answer[onclick*="emergence"]').classList.add('correct');
                feedbackEl.textContent = 'Correct. Welcome, Scientist.';
                feedbackEl.style.color = '#0F6';
                setTimeout(() => {
                    document.getElementById('intro-overlay').classList.add('hiding');
                }, 1500);
                setTimeout(() => {
                    document.getElementById('intro-overlay').style.display = 'none';
                }, 2500); // Hide after transition
                currentGameState = GameState.ATOMICFORGE;
            } else {
                feedbackEl.textContent = 'Not quite. The goal is observation and guidance, not direct control. Please try again.';
                feedbackEl.style.color = '#F06';
            }
        }

        function togglePause() {
            isPaused = !isPaused;
            const pauseBtn = document.getElementById('pause-btn');
            const statusDot = document.getElementById('status-dot');
            const statusText = document.getElementById('status-text');
            
            if (isPaused) {
                pauseBtn.textContent = '‚ñ∂ RESUME';
                statusDot.className = 'status-dot paused';
                statusText.textContent = 'PAUSED';
                pauseStartTime = Date.now();
                
                simulationHistory.events.push({
                    time: getElapsedTime(),
                    type: 'paused',
                    particles: particles.length,
                    molecules: molecules.length
                });
            } else {
                pauseBtn.textContent = '‚è∏ PAUSE';
                statusDot.className = 'status-dot';
                statusText.textContent = 'RUNNING';
                
                const pauseDuration = Date.now() - pauseStartTime;
                startTime += pauseDuration;
                
                simulationHistory.events.push({
                    time: getElapsedTime(),
                    type: 'resumed',
                    particles: particles.length,
                    molecules: molecules.length
                });
            }
        }

        function resetSimulation() {
            if (!confirm('Reset simulation? This will clear all progress.')) {
                return;
            }
            
            particles = [];
            molecules = [];
            particleIdCounter = 0;
            moleculeTypes.clear();
            collisionCount = 0;
            abiogenesisTriggered = false;
            currentLevel = 0;
            firstMoleculeFormed = false; // This should be reset on simulation reset
            currentGameState = GameState.INTRO;
            document.getElementById('atomicforge-controls').style.display = 'block';
            document.getElementById('protoforge-controls').style.display = 'none';
            document.getElementById('protoforge-status').style.display = 'none';
            isPaused = true; // Start paused to show tutorial
            startTime = Date.now();
            elapsedTime = 0;
            
            for (const id in ACHIEVEMENTS) {
                ACHIEVEMENTS[id].unlocked = false;
                // Note: progress function will reset naturally with game state
            }
            
            document.getElementById('pause-btn').textContent = '‚è∏ PAUSE';
            document.getElementById('status-dot').className = 'status-dot';
            document.getElementById('status-text').textContent = 'RUNNING';
            updateLevelUI();
            document.getElementById('level-progress').style.width = '0%';
            
            simulationHistory = {
                startTime: new Date().toISOString(),
                events: [{
                    time: 0,
                    type: 'reset',
                    temperature,
                    density,
                    energyInput
                }],
                snapshots: [],
                achievements: []
            };
            
            adjustParticleCount();
            updateAchievementsDisplay();
            
            // Show tutorial again on reset
            document.getElementById('tutorial').style.display = 'block';
            // Show intro again on reset
            // Show intro again on reset, but don't change its class if it's already hiding
            const intro = document.getElementById('intro-overlay');
            intro.classList.remove('hidden');
            document.getElementById('intro-feedback').innerHTML = '&nbsp;';

            updateMoleculeList();
        }

        let focusResetTimer = null;
        function setCameraFocus(target, zoomLevel = 3.0, duration = 5000) {
            focusTarget = target;
            camera.targetZoom = zoomLevel;

            if (focusResetTimer) {
                clearTimeout(focusResetTimer);
            }

            focusResetTimer = setTimeout(() => {
                focusTarget = null;
                camera.targetX = width / 2;
                camera.targetY = height / 2;
                camera.targetZoom = 1.0;
            }, duration);
        }

        function toggleFocusMode() {
            focusOnNewMolecules = !focusOnNewMolecules;
            const btn = document.getElementById('focus-toggle-btn');
            btn.textContent = `üî¨ FOCUS: ${focusOnNewMolecules ? 'ON' : 'OFF'}`;
            btn.classList.toggle('toggled', focusOnNewMolecules);
        }

        function getElapsedTime() {
            if (isPaused) {
                return elapsedTime;
            }
            elapsedTime = Date.now() - startTime;
            return elapsedTime;
        }

        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateTimer() {
            const elapsed = getElapsedTime();
            document.getElementById('timer').textContent = formatTime(elapsed);
        }

        function updateMoleculeList() {
            const listDiv = document.getElementById('molecule-types');
            if (moleculeTypes.size === 0) {
                listDiv.innerHTML = '<em style="opacity: 0.5;">None yet...</em>';
            } else {
                listDiv.innerHTML = Array.from(moleculeTypes.entries())
                    .map(([type, count]) => `<div class="molecule-item">${type}: ${count}</div>`)
                    .join('');
            }
        }

        function exportData() {
            const exportData = {
                metadata: {
                    exportTime: new Date().toISOString(),
                    totalRunTime: formatTime(getElapsedTime()),
                    version: '2.0.0',
                    totalXP: totalXP
                },
                parameters: {
                    temperature,
                    density,
                    energyInput
                },
                statistics: {
                    totalParticles: particles.length,
                    totalMolecules: molecules.length,
                    uniqueMoleculeTypes: moleculeTypes.size,
                    moleculeBreakdown: Object.fromEntries(moleculeTypes),
                    totalCollisions: collisionCount,
                    averageEnergy: particles.reduce((sum, p) => sum + p.energy, 0) / particles.length || 0
                },
                achievements: {
                    unlocked: Array.from(achievementsUnlocked),
                    total: Object.keys(ACHIEVEMENTS).length,
                    percentage: Math.round((achievementsUnlocked.size / Object.keys(ACHIEVEMENTS).length) * 100),
                    details: Object.values(ACHIEVEMENTS).map(a => ({
                        id: a.id,
                        title: a.title,
                        unlocked: a.unlocked,
                        xp: a.xp
                    }))
                },
                history: simulationHistory,
                currentState: {
                    particles: particles.map(p => ({
                        x: p.x,
                        y: p.y,
                        type: p.type.symbol,
                        bonded: p.bonded
                    })),
                    molecules: molecules.map(m => ({
                        type: m.type,
                        name: m.name,
                        particleCount: m.particles.length,
                        age: Date.now() - m.formed
                    }))
                }
            };
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `atomicforge_${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            simulationHistory.events.push({
                time: getElapsedTime(),
                type: 'exported',
                format: 'json'
            });
        }

        function exportImage() {
            const wasPaused = isPaused;
            if (!wasPaused) {
                isPaused = true;
            }
            
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = width;
            exportCanvas.height = height;
            const exportCtx = exportCanvas.getContext('2d');
            
            exportCtx.fillStyle = '#000';
            exportCtx.fillRect(0, 0, width, height);
            
            // Draw molecules first
            for (let molecule of molecules) {
                const age = Date.now() - molecule.formed;
                const pulseScale = 1 + Math.sin(age / 300) * 0.15;
                
                const gradient = exportCtx.createRadialGradient(molecule.x, molecule.y, 0, molecule.x, molecule.y, 40 * pulseScale);
                gradient.addColorStop(0, 'rgba(0, 255, 255, 0.4)');
                gradient.addColorStop(0.5, 'rgba(0, 255, 255, 0.2)');
                gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
                exportCtx.fillStyle = gradient;
                exportCtx.beginPath();
                exportCtx.arc(molecule.x, molecule.y, 40 * pulseScale, 0, Math.PI * 2);
                exportCtx.fill();
                
                exportCtx.strokeStyle = '#0FF';
                exportCtx.lineWidth = 2;
                exportCtx.globalAlpha = 0.6;
                for (let i = 0; i < molecule.particles.length; i++) {
                    for (let j = i + 1; j < molecule.particles.length; j++) {
                        exportCtx.beginPath();
                        exportCtx.moveTo(molecule.particles[i].x, molecule.particles[i].y);
                        exportCtx.lineTo(molecule.particles[j].x, molecule.particles[j].y);
                        exportCtx.stroke();
                    }
                }
                exportCtx.globalAlpha = 1;
                
                exportCtx.fillStyle = '#0FF';
                exportCtx.font = 'bold 14px "Courier New"';
                exportCtx.textAlign = 'center';
                exportCtx.fillText(molecule.type, molecule.x, molecule.y - 35);
            }
            
            // Draw particles
            for (let particle of particles) {
                if (particle.bonded) {
                    // Convert hex to rgb for proper alpha handling
                    const hex = particle.type.color;
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    const rgb = result ? {
                        r: parseInt(result[1], 16),
                        g: parseInt(result[2], 16),
                        b: parseInt(result[3], 16)
                    } : {r: 255, g: 255, b: 255};
                    
                    const gradient = exportCtx.createRadialGradient(particle.x, particle.y, 0, particle.x, particle.y, particle.size * 3);
                    gradient.addColorStop(0, particle.type.color);
                    gradient.addColorStop(0.5, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.5)`);
                    gradient.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0)`);
                    exportCtx.fillStyle = gradient;
                    exportCtx.beginPath();
                    exportCtx.arc(particle.x, particle.y, particle.size * 3, 0, Math.PI * 2);
                    exportCtx.fill();
                    
                    exportCtx.fillStyle = particle.type.color;
                    exportCtx.beginPath();
                    exportCtx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    exportCtx.fill();
                } else {
                    exportCtx.fillStyle = particle.type.color;
                    exportCtx.fillRect(particle.x - particle.size/2, particle.y - particle.size/2, particle.size, particle.size);
                }
            }
            
            // Add metadata overlay
            exportCtx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            exportCtx.fillRect(10, 10, 350, 120);
            exportCtx.strokeStyle = '#0FF';
            exportCtx.lineWidth = 2;
            exportCtx.strokeRect(10, 10, 350, 120);
            
            exportCtx.fillStyle = '#0FF';
            exportCtx.font = 'bold 16px "Courier New"';
            exportCtx.textAlign = 'left';
            exportCtx.fillText('ATOMICFORGE - Level 0', 20, 35);
            exportCtx.font = '14px "Courier New"';
            exportCtx.fillText(`Time: ${formatTime(getElapsedTime())}`, 20, 60);
            exportCtx.fillText(`Particles: ${particles.length} | Molecules: ${molecules.length}`, 20, 80);
            exportCtx.fillText(`Unique Types: ${moleculeTypes.size}`, 20, 100);
            exportCtx.fillText(`Temp: ${temperature}¬∞K | Density: ${density}`, 20, 120);
            
            exportCanvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `atomicforge_${Date.now()}.png`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                if (!wasPaused) {
                    isPaused = false;
                }
                
                simulationHistory.events.push({
                    time: getElapsedTime(),
                    type: 'exported',
                    format: 'image'
                });
            });
        }

        function showAchievement(moleculeName) {
            if (firstMoleculeFormed) return;
            firstMoleculeFormed = true;
            
            const achievement = document.getElementById('achievement');
            const desc = document.getElementById('achievement-desc');
            desc.innerHTML = `From chaos, order emerges.<br>You have formed ${moleculeName}!`;
            achievement.classList.add('show');
            
            setTimeout(() => {
                achievement.classList.remove('show');
            }, 4000);
        }

        function canBond(p1, p2) {
            // Simple bonding rules based on element types
            const bond = [p1.type.symbol, p2.type.symbol].sort().join('-');
            
            // Define allowed bonds
            const allowedBonds = [
                'H-H', 'H-C', 'H-O', 'H-N',
                'C-C', 'C-O', 'C-N',
                'O-O', 'N-N', 'N-O'
            ];
            
            return allowedBonds.includes(bond);
        }

        function resolveCollision(p1, p2) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            if (distance === 0) distance = 0.001; // prevent division by zero

            // Normal vector (direction of collision)
            const nx = dx / distance;
            const ny = dy / distance;

            // Tangent vector
            const tx = -ny;
            const ty = nx;

            // Project velocities onto normal and tangent vectors
            const dpTan1 = p1.vx * tx + p1.vy * ty;
            const dpTan2 = p2.vx * tx + p2.vy * ty;

            const dpNorm1 = p1.vx * nx + p1.vy * ny;
            const dpNorm2 = p2.vx * nx + p2.vy * ny;

            // Conservation of momentum in 1D (along the normal)
            const m1 = (dpNorm1 * (p1.mass - p2.mass) + 2 * p2.mass * dpNorm2) / (p1.mass + p2.mass);
            const m2 = (dpNorm2 * (p2.mass - p1.mass) + 2 * p1.mass * dpNorm1) / (p1.mass + p2.mass);

            // Update velocities
            p1.vx = tx * dpTan1 + nx * m1;
            p1.vy = ty * dpTan1 + ny * m1;
            p2.vx = tx * dpTan2 + nx * m2;
            p2.vy = ty * dpTan2 + ny * m2;

            // Separate overlapping particles to prevent sticking
            const overlap = (p1.size + p2.size + 2) - distance;
            if (overlap > 0) {
                const separationX = nx * overlap * 0.5;
                const separationY = ny * overlap * 0.5;
                p1.x -= separationX;
                p1.y -= separationY;
                p2.x += separationX;
                p2.y += separationY;
            }
        }

        function checkCollisions(tempFactor) {
            // 1. Clear and rebuild the hash grid each frame
            spatialHash.clear();
            for (const particle of particles) {
                if (!particle.bonded) {
                    spatialHash.insert(particle);
                }
            }

            // 2. Iterate through particles and check only against nearby ones
            for (const p1 of particles) {
                if (p1.bonded) continue;

                const nearbyParticles = spatialHash.getNearby(p1);
                for (const p2 of nearbyParticles) {
                    // Avoid self-collision and duplicate checks (p1.id < p2.id)
                    if (p1.id >= p2.id || p2.bonded) continue;

                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    const collisionDist = p1.size + p2.size + 2;

                    if (dist < collisionDist) {
                        collisionCount++;

                        // Collision flash
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.beginPath();
                        ctx.arc(p1.x, p1.y, 4, 0, Math.PI * 2);
                        ctx.fill();

                        // Bonding probability is highest around 50K and lower at the edges.                        
                        const bondingChance = 0.005 * tempFactor;

                        // Check for bonding
                        if (canBond(p1, p2) &&
                            temperature > 25 && temperature < 75 &&
                            Math.random() < bondingChance) {

                            // Form molecule!
                            const molecule = new Molecule([p1, p2]);
                            molecules.push(molecule);

                            // Track molecule types
                            const count = moleculeTypes.get(molecule.name) || 0;
                            moleculeTypes.set(molecule.name, count + 1);
                            updateMoleculeList();

                            if (!firstMoleculeFormed) {
                                showAchievement(molecule.name);
                            }

                            simulationHistory.events.push({
                                time: getElapsedTime(),
                                type: 'molecule_formed',
                                moleculeType: molecule.type,
                                moleculeName: molecule.name
                            });
                        } else {
                            resolveCollision(p1, p2);
                        }
                    }
                }
            }
        }

        function checkMoleculeReactions() {
            if (currentLevel < 2) return; // Reactions start becoming important in level 2

            for (const molecule of molecules) {
                if (molecule.particles.length >= 10) continue; // Cap complexity for performance

                const nearbyParticles = spatialHash.getNearby(molecule.particles[0]);
                for (const particle of nearbyParticles) {
                    if (particle.bonded) continue;

                    const dist = Math.sqrt(Math.pow(molecule.x - particle.x, 2) + Math.pow(molecule.y - particle.y, 2));
                    if (dist < 30) { // Interaction radius for molecule-particle
                        const reactionChance = 0.0001 * (temperature / 50); // Simple temp factor for now
                        if (Math.random() < reactionChance) {
                            // A new particle joins the molecule
                            const oldMoleculeName = molecule.name;
                            moleculeTypes.set(oldMoleculeName, (moleculeTypes.get(oldMoleculeName) || 1) - 1);
                            if (moleculeTypes.get(oldMoleculeName) <= 0) {
                                moleculeTypes.delete(oldMoleculeName);
                            }

                            particle.bonded = true;
                            particle.molecule = molecule;
                            molecule.particles.push(particle);
                            
                            // Recalculate properties
                            molecule.type = molecule.getMoleculeType();
                            molecule.name = molecule.getMoleculeName();
                            
                            const newMoleculeName = molecule.name;
                            moleculeTypes.set(newMoleculeName, (moleculeTypes.get(newMoleculeName) || 0) + 1);
                            
                            if (focusOnNewMolecules) {
                                setCameraFocus(molecule, 4.0);
                            }

                            updateMoleculeList();
                            return; // One reaction per frame to avoid chaos
                        }
                    }
                }
            }
        }

        function updateRealTimeHelp() {
            if (!currentHelpAchievementId) return;

            const helpData = ACHIEVEMENT_HELP[currentHelpAchievementId];
            if (!helpData) return;

            // Update progress
            updateHelpProgress(currentHelpAchievementId, helpData);

            // Update parameter highlighting
            const params = helpData.parameters;
            if (params) {
                updateParamHighlight('temperature', temperature, params.temperature);
                updateParamHighlight('density', density, params.density);
                updateParamHighlight('energy', energyInput, params.energy);
            }
        }

        function updateParamHighlight(paramName, currentValue, recommendedValue) {
            const paramElement = document.getElementById(`help-param-${paramName}`);
            if (!paramElement) return;

            const statusElement = paramElement.querySelector('.param-status');
            paramElement.classList.remove('in-range', 'out-of-range');

            if (recommendedValue.toLowerCase() === 'any') {
                statusElement.textContent = '';
                return;
            }

            let min, max;
            if (recommendedValue.includes('-')) {
                [min, max] = recommendedValue.match(/\d+/g).map(Number);
            } else if (recommendedValue.includes('+')) {
                min = Number(recommendedValue.match(/\d+/)[0]);
                max = Infinity;
            } else {
                min = max = Number(recommendedValue.match(/\d+/)[0]);
            }

            if (currentValue >= min && currentValue <= max) {
                paramElement.classList.add('in-range');
                statusElement.textContent = '‚úì';
                statusElement.style.color = 'var(--success-color)';
            } else {
                paramElement.classList.add('out-of-range');
                if (currentValue < min) {
                    statusElement.textContent = '‚ñ≤'; // Needs to go up
                } else {
                    statusElement.textContent = '‚ñº'; // Needs to go down
                }
                statusElement.style.color = 'var(--warning-color)';
            }
        }

        function transitionToLifeForge(protoCell) {
            // This function will be expanded to initialize the LifeForge simulation
        }

        function transitionToProtoForge(createdProtoCell) {
            currentGameState = GameState.PROTOFORGE;
            protoCell = createdProtoCell;
            
            // Set camera focus on the new proto-cell
            abiogenesisFocus = false;
            camera.targetX = width / 2;
            camera.targetY = height / 2;
            camera.targetZoom = 1.0;
            setCameraFocus(protoCell, 6.0, 999999); // Long duration focus

            console.log("Transitioning to LifeForge with proto-cell:", protoCell);
            // Hide AtomicForge elements and show ProtoForge UI
            document.getElementById('atomicforge-controls').style.display = 'none';
            document.getElementById('protoforge-controls').style.display = 'block';
            document.getElementById('protoforge-status').style.display = 'block';
            document.querySelector('.level-title').textContent = 'PROTOFORGE - Level 3';

            // Fade out other particles/molecules
            particles.forEach(p => { if (p.molecule !== protoCell) p.fade = true; });
            molecules.forEach(m => { if (m !== protoCell) m.fade = true; });

            const overlay = document.getElementById('abiogenesis-overlay');
            const title = document.getElementById('abiogenesis-title');
            
            // For now, we can just display a message and reset
            overlay.classList.add('show');

            setTimeout(() => { title.textContent = "From chemistry, biology..."; }, 1000);
            setTimeout(() => { title.textContent = "Nurture the spark of life."; }, 5000);
            setTimeout(() => { overlay.classList.remove('show'); }, 8000);
        }

        function transitionToFullLifeForge() { // Renamed to avoid conflict
            currentGameState = GameState.LIFEFORGE;
            console.log("Transitioning to LifeForge with evolved genome:", protoCell.genome);

            const overlay = document.getElementById('abiogenesis-overlay');
            const title = document.getElementById('abiogenesis-title');
            overlay.classList.add('show');
            title.textContent = "LIFEFORGE";

            setTimeout(() => {
                const overlay = document.getElementById('abiogenesis-overlay');
                overlay.classList.remove('show');
                alert("Congratulations! You've reached LifeForge. The simulation will now reset to demonstrate the complete loop. The next phase of development starts here!");
                alert("Congratulations! You have successfully nurtured the first cell. The simulation will now reset as we prepare to build the full LifeForge stage.");
                resetSimulation();
            }, 5000);
        }

        class AbiogenesisDetector {
            check() {
                if (abiogenesisTriggered || currentLevel < 3) return;
                if (currentGameState !== GameState.ATOMICFORGE || abiogenesisTriggered || currentLevel < 3) return;

                const hasLipids = (moleculeTypes.get('Lipid Precursor') || 0) > 5;
                const hasAminoAcids = (moleculeTypes.get('Glycine (Amino Acid)') || 0) > 5;
                const hasWater = moleculeTypes.has('H‚ÇÇO (Water)')

                if (hasLipids && hasAminoAcids && hasWater && Math.random() < 0.0001) { // Made it rarer for dramatic effect
                    this.trigger();
                }
            }

            trigger() {
                if (abiogenesisTriggered) return;
                abiogenesisTriggered = true;
                console.log("ABIOGENESIS TRIGGERED!");
                
                // 1. Pause the simulation immediately
                if (!isPaused) {
                    togglePause();
                }
                console.log("Proto-cell formation detected! Transitioning to ProtoForge.");

                // 2. Set up the camera focus
                abiogenesisFocus = true;
                abiogenesisFocusTarget = molecules.find(m => m.name === 'Glycine (Amino Acid)') || molecules[molecules.length - 1];
                if (abiogenesisFocusTarget) {
                    camera.targetZoom = 8.0; // Zoom in 8x
                }

                // 2. Find a "proto-cell" to focus on (a complex molecule)
                const protoCell = molecules.find(m => m.name === 'Glycine (Amino Acid)') || molecules[molecules.length - 1];

                // 3. Start the celebration sequence
                const overlay = document.getElementById('abiogenesis-overlay');
                const title = document.getElementById('abiogenesis-title');
                
                overlay.classList.add('show');

                setTimeout(() => {
                    title.textContent = "From chaos, order emerges...";
                }, 1000);

                setTimeout(() => {
                    title.textContent = "From chemistry, biology...";
                }, 5000);

                setTimeout(() => {
                    title.textContent = "And life... ignites.";
                    unlockAchievement('abiogenesis'); // Unlock the achievement at the peak moment
                }, 9000);

                // 4. After the sequence, transition to LifeForge
                setTimeout(() => {
                    transitionToFullLifeForge(protoCell);
                }, 14000);
                unlockAchievement('abiogenesis');
                transitionToProtoForge(protoCell);
            }
        }
        const abiogenesisDetector = new AbiogenesisDetector();

        // Cache DOM elements for stats
        const statElements = {
            particleCount: document.getElementById('particle-count'),
            moleculeCount: document.getElementById('molecule-count'),
            uniqueMolecules: document.getElementById('unique-molecules'),
            collisionCount: document.getElementById('collision-count'),
            avgEnergy: document.getElementById('avg-energy')
        };

        // Cache DOM elements for popups
        const levelUpPopupElements = {
            popup: document.getElementById('level-up-popup'),
            subtitle: document.getElementById('level-up-subtitle'),
            unlocks: document.getElementById('level-up-unlocks')
        };

        function updateStats() {
            statElements.particleCount.textContent = particles.length;
            statElements.moleculeCount.textContent = molecules.length;
            statElements.uniqueMolecules.textContent = moleculeTypes.size;
            statElements.collisionCount.textContent = collisionCount;
            
            const freeParticles = particles.filter(p => !p.bonded);
            const avgEnergy = freeParticles.length > 0 
                ? freeParticles.reduce((sum, p) => sum + p.energy, 0) / freeParticles.length
                : 0;
            statElements.avgEnergy.textContent = avgEnergy.toFixed(1);
        }

        function updateLevelUI() {
            const levelTitle = document.querySelector('.level-title');
            if (levelTitle) {
                levelTitle.textContent = `ATOMICFORGE - Level ${currentLevel}`;
            }
        }

        function updateLevelProgress() {
            if (currentLevel >= LEVEL_DEFINITIONS.length) return; // Max level reached

            const levelDef = LEVEL_DEFINITIONS[currentLevel];
            const progress = levelDef.getProgress();
            document.getElementById('level-progress').style.width = progress + '%';

            if (progress >= 100 && levelDef.checkCompletion()) {
                levelUp();
            }
        }

        function levelUp() {
            currentLevel++;
            totalXP += LEVEL_DEFINITIONS[currentLevel - 1].xp_reward;
            updateLevelUI();
            showLevelUp(currentLevel);
        }

        function showLevelUp(newLevel) {
            levelUpPopupElements.subtitle.textContent = `You've reached Level ${newLevel}!`;
            if (newLevel < LEVEL_DEFINITIONS.length) {
                levelUpPopupElements.unlocks.innerHTML = `<strong>New Unlock:</strong> ${LEVEL_DEFINITIONS[newLevel-1].unlocks}`;
            } else {
                levelUpPopupElements.unlocks.innerHTML = `<strong>Congratulations!</strong> You have reached the maximum level for this demo.`;
            }
            levelUpPopupElements.popup.classList.add('show');
            setTimeout(() => levelUpPopupElements.popup.classList.remove('show'), 4000);
        }

        // Animation loop
        let lastSnapshotTime = 0;
        
        function animate() {
            updateTimer();
            
            if (isPaused && !abiogenesisFocus) {
                animationId = requestAnimationFrame(animate);
                return;
            }

            ctx.save();

            // Camera movement and zoom
            if (abiogenesisFocus && abiogenesisFocusTarget) {
                camera.targetX = abiogenesisFocusTarget.x;
                camera.targetY = abiogenesisFocusTarget.y;
            }
            camera.x += (camera.targetX - camera.x) * camera.lerpFactor;
            camera.y += (camera.targetY - camera.y) * camera.lerpFactor;
            camera.zoom += (camera.targetZoom - camera.zoom) * camera.lerpFactor;

            // Apply camera transform
            ctx.translate(width / 2, height / 2);
            ctx.scale(camera.zoom, camera.zoom);
            ctx.translate(-camera.x, -camera.y);
            
            // Calculate temperature factor once per frame for use in other functions
            const optimalTemp = 50;
            const tempDifference = Math.abs(temperature - optimalTemp);
            const tempFactor = Math.max(0, 1 - (tempDifference / 25)); // Max reduction at 25 and 75

            // Take periodic snapshots
            const currentTime = getElapsedTime();
            if (currentTime - lastSnapshotTime > 10000) {
                simulationHistory.snapshots.push({
                    time: currentTime,
                    particles: particles.length,
                    molecules: molecules.length,
                    uniqueTypes: moleculeTypes.size,
                    collisions: collisionCount,
                    temperature,
                    density,
                    energyInput
                });
                lastSnapshotTime = currentTime;
            }
            
            // Clear with trail effect
            const inverseZoom = 1 / camera.zoom;
            ctx.fillStyle = abiogenesisFocus ? 'rgba(0, 0, 0, 0.25)' : 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(camera.x - (width / 2) * inverseZoom, camera.y - (height / 2) * inverseZoom, width * inverseZoom, height * inverseZoom);

            // Update and draw particles
            for (let particle of particles) {
                if (!isPaused) {
                    particle.update(temperature, energyInput);
                }
                if (abiogenesisFocus && (!particle.molecule || particle.molecule.id !== abiogenesisFocusTarget.id)) {
                    ctx.globalAlpha = 0.1; // Fade out non-target particles
                }
                particle.draw();
                ctx.globalAlpha = 1.0;
            }

            // Check collisions
            if (!isPaused) {
                checkCollisions(tempFactor);
            }

            // Check for more complex reactions
            if (!isPaused) {
                checkMoleculeReactions();
            }

            // Check for the ultimate emergence
            if (!isPaused) {
                abiogenesisDetector.check();
            }

            // Draw molecules
            for (let molecule of molecules) {
                if (abiogenesisFocus && molecule.id !== abiogenesisFocusTarget.id) {
                    ctx.globalAlpha = 0.1; // Fade out non-target molecules
                }
                molecule.draw();
                ctx.globalAlpha = 1.0;
            }

            // Update stats
            updateStats();
            
            // Update Level Progress
            updateLevelProgress();

            if (currentGameState === GameState.PROTOFORGE && protoCell) {
                protoCell.updateProtoCell();
                const statusDiv = document.getElementById('protoforge-status');
                statusDiv.innerHTML = `
                    <h3>Proto-Cell Status</h3>
                    <p>Energy: ${protoCell.energy.toFixed(2)}</p>
                    <p>Integrity: ${protoCell.integrity.toFixed(2)}%</p>
                    <p>Replications: ${protoCell.replications}</p>
                `;
                if (protoCell.replications >= 3) {
                    transitionToFullLifeForge();
                }
            }


            // Update help panel if open
            updateRealTimeHelp();

            // Special achievement tracking
            // Thermodynamist: Keep temp between 45-55 for 30s
            if (temperature >= 45 && temperature <= 55) {
                if (!isPaused) {
                    // This is a simple way to track time. A more robust way would use deltaTime.
                    // Assuming ~60fps, 16.67ms per frame.
                    thermoTimeInRange += 1000 / 60; 
                }
            } else {
                thermoTimeInRange = 0; // Reset if temp goes out of range
            }

            // Check achievements every frame
            checkAchievements();

            ctx.restore();
            animationId = requestAnimationFrame(animate);
        }

        // ACHIEVEMENT HELP FUNCTIONS
        function showAchievementHelp(achievementId) {
            const help = ACHIEVEMENT_HELP[achievementId];
            const achievement = ACHIEVEMENTS[achievementId];
            
            if (!help) return;

            // Update help content
            document.getElementById('achievement-help-icon').textContent = achievement.icon;
            document.getElementById('achievement-help-title').textContent = achievement.title;
            document.getElementById('achievement-help-xp').textContent = `+${achievement.xp} XP`;
            document.getElementById('achievement-help-description').textContent = help.description;
            
            // Update progress
            updateHelpProgress(achievementId, help);
            
            // Update strategy
            const strategyList = document.getElementById('achievement-help-strategy-list');
            strategyList.innerHTML = help.strategy.map(item => `<li>${item}</li>`).join('');
            
            // Update parameters
            const paramsDiv = document.getElementById('achievement-help-parameters');
            paramsDiv.innerHTML = `
                <div class="param-item" id="help-param-temperature">
                    <div><div class="param-label">Temperature</div><div class="param-value">${help.parameters.temperature}</div></div>
                    <div class="param-status"></div>
                </div>
                <div class="param-item" id="help-param-density">
                    <div><div class="param-label">Density</div><div class="param-value">${help.parameters.density}</div></div>
                    <div class="param-status"></div>
                </div>
                <div class="param-item" id="help-param-energy">
                    <div><div class="param-label">Energy</div><div class="param-value">${help.parameters.energy}</div></div>
                    <div class="param-status"></div>
                </div>
            `;
            // Initial highlight update
            updateRealTimeHelp();
            
            // Update formula
            document.getElementById('achievement-help-formula').textContent = help.formula;
            
            // Show/hide sections based on achievement type
            const hintTip = document.getElementById('achievement-help-hint');
            
            // Special cases
            if (help.hint) {
                hintTip.textContent = `üí° ${help.hint}`;
            } else if (achievementId === 'thermodynamist') {
                hintTip.textContent = "üí° Use small adjustments and watch the temperature value carefully!";
            } else if (achievementId === 'patient_chemist') {
                hintTip.textContent = "üí° Let the simulation run in the background while you observe the patterns!";
            } else if (achievementId === 'master_chemist') {
                hintTip.textContent = "üí° Check each achievement's help for specific strategies!";
            } else {
                hintTip.textContent = "üí° Pro-Tip: Adjust parameters gradually and observe the results!";
            }
            
            // Show the help panel
            document.getElementById('achievement-help').classList.add('show');
            currentHelpAchievementId = achievementId;
        }

        function updateHelpProgress(achievementId, helpData) {
            const achievement = ACHIEVEMENTS[achievementId];
            const progressInfo = document.getElementById('achievement-help-progress-info');
            const progressBar = document.getElementById('help-progress-bar');
            
            if (achievement.unlocked) {
                progressInfo.textContent = "‚úÖ Achievement Unlocked!";
                progressBar.style.width = "100%";
                return;
            }
            
            // Calculate current progress
            let current = 0;
            let target = 1;
            let progressText = "";
            
            switch(achievementId) {
                case 'hydrogen_factory':
                    current = moleculeTypes.get('H‚ÇÇ (Hydrogen)') || 0;
                    target = 5;
                    progressText = `${current}/5 H‚ÇÇ molecules formed`;
                    break;
                case 'molecular_diversity':
                    current = moleculeTypes.size;
                    target = 5;
                    progressText = `${current}/5 unique molecule types`;
                    break;
                case 'speed_demon':
                    current = collisionCount;
                    target = 50000;
                    progressText = `${current.toLocaleString()}/50,000 collisions`;
                    break;
                case 'molecular_factory':
                    current = molecules.length;
                    target = 20;
                    progressText = `${current}/20 total molecules`;
                    break;
                case 'patient_chemist':
                    current = getElapsedTime();
                    target = 300000; // 5 minutes in milliseconds
                    const minutes = Math.floor(current / 60000);
                    const seconds = Math.floor((current % 60000) / 1000);
                    progressText = `${minutes}m ${seconds}s / 5m 0s`;
                    break;
                case 'water_of_life':
                    current = moleculeTypes.has('H‚ÇÇO (Water)') ? 1 : 0;
                    target = 1;
                    progressText = current ? "H‚ÇÇO formed!" : "H‚ÇÇO not yet formed";
                    break;
                case 'radical_creator':
                    current = moleculeTypes.has('OH (Hydroxyl)') ? 1 : 0;
                    target = 1;
                    progressText = current ? "OH formed!" : "OH not yet formed";
                    break;
                case 'toxic_chemist':
                    current = moleculeTypes.has('CN (Cyanide)') ? 1 : 0;
                    target = 1;
                    progressText = current ? "CN formed!" : "CN not yet formed";
                    break;
                case 'ammonia_maker':
                    current = moleculeTypes.has('NH‚ÇÉ (Ammonia)') ? 1 : 0;
                    target = 1;
                    progressText = current ? "NH‚ÇÉ formed!" : "NH‚ÇÉ not yet formed";
                    break;
                case 'carbon_dioxide':
                    current = moleculeTypes.has('CO‚ÇÇ (Carbon Dioxide)') ? 1 : 0;
                    target = 1;
                    progressText = current ? "CO‚ÇÇ formed!" : "CO‚ÇÇ not yet formed";
                    break;
                case 'nitrogen_gas':
                    current = moleculeTypes.has('N‚ÇÇ (Nitrogen)') ? 1 : 0;
                    target = 1;
                    progressText = current ? "N‚ÇÇ formed!" : "N‚ÇÇ not yet formed";
                    break;
                case 'prebiotic_soup':
                    const hasWater = moleculeTypes.has('H‚ÇÇO (Water)');
                    const hasAmmonia = moleculeTypes.has('NH‚ÇÉ (Ammonia)');
                    const hasCyanide = moleculeTypes.has('HCN');
                    current = (hasWater ? 1 : 0) + (hasAmmonia ? 1 : 0) + (hasCyanide ? 1 : 0);
                    target = 3;
                    let presentMolecules = [];
                    if (hasWater) presentMolecules.push('H‚ÇÇO');
                    if (hasAmmonia) presentMolecules.push('NH‚ÇÉ');
                    if (hasCyanide) presentMolecules.push('HCN');
                    
                    let missingMolecules = [];
                    if (!hasWater) missingMolecules.push('H‚ÇÇO');
                    if (!hasAmmonia) missingMolecules.push('NH‚ÇÉ');
                    if (!hasCyanide) missingMolecules.push('HCN');
                    
                    if (current === 0) {
                        progressText = "None formed yet. Need H‚ÇÇO, NH‚ÇÉ, HCN.";
                    } else if (current === target) {
                        progressText = "All building blocks formed!";
                    } else {
                        progressText = `Formed: ${presentMolecules.join(', ')}. Missing: ${missingMolecules.join(', ')}.`;
                    }
                    break;
                case 'master_chemist':
                    const unlocked = Object.values(ACHIEVEMENTS).filter(a => a.unlocked && a.id !== 'master_chemist').length;
                    current = unlocked;
                    target = Object.keys(ACHIEVEMENTS).length - 1;
                    progressText = `${unlocked}/${target} achievements unlocked`;
                    break;
                default:
                    progressText = achievement.unlocked ? "Completed!" : "Not started";
            }
            
            const progressPercent = Math.min(100, (current / target) * 100);
            
            progressInfo.textContent = progressText;
            progressBar.style.width = `${progressPercent}%`;
        }

        function closeHelp() {
            document.getElementById('achievement-help').classList.remove('show');
            currentHelpAchievementId = null;
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case ' ':
                case 'p':
                    e.preventDefault();
                    togglePause();
                    break;
                case 'r':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        resetSimulation();
                    }
                    break;
                case 's':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        exportData();
                    }
                    break;
                case 'i':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        exportImage();
                    }
                    break;
                case 'e':
                    // Toggle element key
                    toggleElementKey();
                    break;
                case 'm':
                    // Toggle molecule list
                    toggleMoleculeList();
                    break;
                case 'a':
                    // Toggle achievements
                    toggleAchievements();
                    break;
                case 'h':
                    // Achievement help (when viewing achievements)
                    if (!document.getElementById('achievements-panel').classList.contains('minimized')) {
                        e.preventDefault();
                        // Show help for first locked achievement or master chemist
                        const lockedAchievements = Object.values(ACHIEVEMENTS).filter(a => !a.unlocked);
                        if (lockedAchievements.length > 0) {
                            showAchievementHelp(lockedAchievements[0].id);
                        } else {
                            showAchievementHelp('master_chemist');
                        }
                } else if (helpPanel.classList.contains('show')) {
                    e.preventDefault();
                    closeHelp();
                    }
                    break;
            }
        });

        // Toggle functions for panels
        function toggleElementKey() {
            const panel = document.getElementById('element-key');
            const icon = document.getElementById('element-toggle');
            panel.classList.toggle('minimized');
            icon.textContent = panel.classList.contains('minimized') ? '[+]' : '[-]';
        }

        function toggleMoleculeList() {
            const panel = document.getElementById('molecule-list');
            const icon = document.getElementById('molecule-toggle');
            panel.classList.toggle('minimized');
            icon.textContent = panel.classList.contains('minimized') ? '[+]' : '[-]';
        }

        function toggleAchievements() {
            const panel = document.getElementById('achievements-panel');
            const icon = document.getElementById('achievements-toggle');
            panel.classList.toggle('minimized');
            icon.textContent = panel.classList.contains('minimized') ? '[+]' : '[-]';
        }

        function checkAchievements() {
            for (const [id, achievement] of Object.entries(ACHIEVEMENTS)) {
                if (!achievement.unlocked && achievement.check()) {
                    unlockAchievement(id);
                }
            }
            updateAchievementsDisplay();
        }

        function unlockAchievement(id) {
            const achievement = ACHIEVEMENTS[id];
            if (achievement.unlocked) return;
            
            achievement.unlocked = true;
            achievementsUnlocked.add(id);
            totalXP += achievement.xp;
            
            // Log to history
            simulationHistory.achievements.push({
                time: getElapsedTime(),
                id: id,
                title: achievement.title,
                xp: achievement.xp
            });
            
            // Show popup
            showAchievementPopup(achievement);
            
            // Update display
            updateAchievementsDisplay();
        }

        function showAchievementPopup(achievement) {
            const popup = document.getElementById('achievement-popup');
            document.getElementById('popup-icon').textContent = achievement.icon;
            document.getElementById('popup-title').textContent = 'Achievement Unlocked!';
            document.getElementById('popup-subtitle').textContent = achievement.title;
            document.getElementById('popup-desc').textContent = achievement.description;
            document.getElementById('popup-xp').textContent = `+${achievement.xp} XP`;
            
            popup.classList.add('show');
            
            setTimeout(() => {
                popup.classList.remove('show');
            }, 4000);
        }

        function updateAchievementsDisplay() {
            const unlockedCount = Object.values(ACHIEVEMENTS).filter(a => a.unlocked).length;
            const totalCount = Object.keys(ACHIEVEMENTS).length;
            const percentage = Math.round((unlockedCount / totalCount) * 100);
            
            document.getElementById('achievement-count').textContent = `${unlockedCount} / ${totalCount} Unlocked`;
            document.getElementById('achievement-percent').textContent = `${percentage}% Complete`;
            
            const listDiv = document.getElementById('achievements-list');
            listDiv.innerHTML = Object.values(ACHIEVEMENTS).map(achievement => {
                const locked = !achievement.unlocked;
                const progressHTML = achievement.progress && locked ? 
                    `<div class="achievement-progress">
                        Progress: ${Math.round(achievement.progress())}%
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${achievement.progress()}%"></div>
                        </div>
                    </div>` : '';
                
                return `
                    <div class="achievement-item ${locked ? 'locked' : 'unlocked'} clickable" 
                         onclick="showAchievementHelp('${achievement.id}')">
                        <div class="achievement-header">
                            <span class="achievement-icon">${achievement.icon}</span>
                            <span class="achievement-title">${achievement.title}</span>
                            <span class="achievement-status ${locked ? 'locked' : 'unlocked'}">
                                ${locked ? 'üîí' : '‚úì'}
                            </span>
                        </div>
                        <div class="achievement-desc">${achievement.description}</div>
                        ${progressHTML}
                    </div>
                `;
            }).join('');
        }

        // Close help when clicking outside (optional)
        document.addEventListener('click', (e) => {
            const helpPanel = document.getElementById('achievement-help');
            if (e.target === helpPanel) {
                closeHelp();
            }
        });

        // Close help with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeHelp();
            }
        });

        // --- INTRO CANVAS SCRIPT ---
        const introCanvas = document.getElementById('intro-canvas');
        const introCtx = introCanvas.getContext('2d');
        let introParticles = [];

        function resizeIntroCanvas() {
            introCanvas.width = window.innerWidth;
            introCanvas.height = window.innerHeight;
        }

        class IntroParticle {
            constructor() {
                this.x = Math.random() * introCanvas.width;
                this.y = Math.random() * introCanvas.height;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.size = Math.random() * 2 + 1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                if (this.x < 0 || this.x > introCanvas.width) this.vx *= -1;
                if (this.y < 0 || this.y > introCanvas.height) this.vy *= -1;
            }

            draw() {
                introCtx.fillStyle = 'rgba(0, 255, 255, 0.8)';
                introCtx.beginPath();
                introCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                introCtx.fill();
            }
        }

        function initIntroAnimation() {
            resizeIntroCanvas();
            for (let i = 0; i < 100; i++) {
                introParticles.push(new IntroParticle());
            }
            animateIntro();
        }

        function animateIntro() {
            introCtx.clearRect(0, 0, introCanvas.width, introCanvas.height);
            introParticles.forEach(p => {
                p.update();
                p.draw();
            });
            requestAnimationFrame(animateIntro);
        }
        // Initialize achievements display
        updateAchievementsDisplay();
        
        // Set initial pause state for tutorial
        document.getElementById('status-dot').className = 'status-dot paused';
        document.getElementById('status-text').textContent = 'PAUSED';
        updateLevelUI();
        
        simulationHistory.events.push({
            time: 0,
            type: 'simulation_start',
            temperature,
            density,
            energyInput
        });
        
        adjustParticleCount();
        animate();

        // Start the intro animation
        initIntroAnimation();
    </script>
    <script src="data.js"></script>
    <script src="simulation.js"></script>
</body>
</html>