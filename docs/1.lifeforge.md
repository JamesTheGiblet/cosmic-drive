# 🌌 FORGE COSMOS - COMPLETE DEVELOPMENT BIBLE (CONTINUED)

## 🧬 LifeForge - Cellular Evolution

### Overview

**LifeForge is where chemistry becomes biology.** Starting from the proto-cell that emerged in AtomicForge, players guide the evolution of increasingly complex life forms through the power of mutation, selection, and time.

### Design Goals

1. **Make evolution intuitive** - show it happening in real-time
2. **Demonstrate natural selection** - better-adapted organisms thrive
3. **Show the power of time** - small changes accumulate into dramatic differences
4. **Teach genetics** - traits are inherited, mutations create variation
5. **Set up multi-cellularity** - cooperation between cells unlocks complexity

### The Three Phases

```
PHASE 1: SINGLE-CELL LIFE (Levels 4-6)
└─ Proto-cell → Diverse single-celled organisms

PHASE 2: MULTI-CELLULARITY (Levels 7-10)
└─ Cell colonies → True multicellular organisms

PHASE 3: COMPLEX ORGANISMS (Levels 11-13)
└─ Differentiation → Organs → Body plans
```

---

### Phase 1: Single-Cell Life (Levels 4-6)

#### The Rules

```javascript
CELL_RULES = {
  metabolism: {
    description: "Cells consume energy to survive",
    formula: "energy_loss = base_metabolic_rate * mass",
    mechanic: "Must eat resources or die"
  },
  
  reproduction: {
    description: "Divide when energy threshold reached",
    formula: "if (energy >= reproduction_threshold) { divide() }",
    cost: "Reproduction uses stored energy",
    mechanic: "Energy → split into two cells"
  },
  
  mutation: {
    description: "Small random changes each generation",
    formula: "new_genome = parent_genome + random_mutations",
    rate: "Player-controlled slider (0.001 - 0.1 per generation)",
    mechanic: "Children differ slightly from parents"
  },
  
  death: {
    description: "Insufficient energy = cell death",
    formula: "if (energy <= 0) { die() }",
    consequences: "Dead cells become resources",
    mechanic: "Death is permanent but feeds ecosystem"
  },
  
  selection: {
    description: "Better-adapted cells survive longer",
    formula: "fitness = survival_time * offspring_count",
    emergent: "No explicit fitness function - environment selects",
    mechanic: "The environment is the judge"
  }
};
```

#### The Genome System

```javascript
class Genome {
  constructor() {
    // Traits encoded as real numbers (0-1)
    this.traits = {
      // Movement
      speed: 0.5,              // 0 = slow, 1 = fast
      turning_rate: 0.5,       // 0 = straight, 1 = erratic
      
      // Metabolism
      metabolic_rate: 0.5,     // 0 = efficient, 1 = hungry
      energy_storage: 0.5,     // 0 = small reserve, 1 = large
      
      // Size
      size: 0.5,               // 0 = tiny, 1 = large
      
      // Senses (unlocked later)
      light_sensitivity: 0.0,  // 0 = blind, 1 = photosensitive
      chemical_sensitivity: 0.0, // 0 = oblivious, 1 = chemotaxis
      
      // Reproduction
      reproduction_threshold: 0.5, // 0 = reproduce quickly, 1 = save energy
      offspring_count: 0.0,    // 0 = one child, 1 = multiple (budding)
      
      // Defense (unlocked later)
      armor: 0.0,              // 0 = fragile, 1 = tough
      toxin: 0.0,              // 0 = harmless, 1 = poisonous
      
      // Color (cosmetic, but affects predation later)
      hue: random(0, 360),     // HSL hue value
      saturation: 0.5,         // 0 = gray, 1 = vibrant
    };
  }
  
  mutate(mutationRate) {
    for (let trait in this.traits) {
      if (Math.random() < mutationRate) {
        // Gaussian mutation: small changes most common
        let change = this.gaussianRandom(0, 0.1);
        this.traits[trait] += change;
        
        // Clamp to valid range
        this.traits[trait] = Math.max(0, Math.min(1, this.traits[trait]));
      }
    }
    
    // Color mutation is special (wraps around)
    if (Math.random() < mutationRate) {
      this.traits.hue = (this.traits.hue + this.gaussianRandom(0, 30)) % 360;
    }
  }
  
  gaussianRandom(mean, stdDev) {
    // Box-Muller transform for Gaussian distribution
    let u1 = Math.random();
    let u2 = Math.random();
    let z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    return mean + stdDev * z0;
  }
  
  // Phenotype expression: genome → visible traits
  getPhenotype() {
    return {
      speed: this.traits.speed * 100, // 0-100 pixels/sec
      turning: this.traits.turning_rate * Math.PI, // 0-180 degrees/sec
      metabolism: 1 + (this.traits.metabolic_rate * 2), // 1-3 energy/sec
      maxEnergy: 50 + (this.traits.energy_storage * 150), // 50-200 energy
      radius: 4 + (this.traits.size * 12), // 4-16 pixels
      color: this.getColor()
    };
  }
  
  getColor() {
    return `hsl(${this.traits.hue}, ${this.traits.saturation * 100}%, 50%)`;
  }
}
```

#### Level 4: Cellular Architect

**Goal:** Keep your first cell alive and reproducing

**Tutorial Flow:**

```
1. FADE IN from AtomicForge
   └─ Proto-cell in center of screen, pulsing
   
2. "This is life."
   └─ Cell glows with cyan life force
   
3. "It needs energy."
   └─ Green resource particles appear nearby
   └─ Cell slowly drifts toward them (random walk)
   
4. Cell touches resource
   └─ Resource disappears
   └─ Cell's energy increases (visible meter)
   └─ "Good. It's feeding."
   
5. Energy fills up
   └─ Cell grows slightly larger
   └─ "When energy is full, it will divide."
   
6. Cell reaches threshold
   └─ Division animation:
      ●  →  ● ●  (splits into two)
   └─ ACHIEVEMENT UNLOCKED: 🐣 Genesis Event
   
7. Two cells now exist
   └─ Each has slightly different genome (mutation)
   └─ "Life has begun to evolve."
   
8. UI fades in
   └─ Show energy meters for all cells
   └─ Show generation counter
   └─ Show mutation rate slider
   
9. "Your task: Guide its evolution."
   └─ Tutorial ends
   └─ Player now in control
```

**Player Controls:**

```
┌─────────────────────────────────────────────┐
│ LIFEFORGE CONTROLS                          │
├─────────────────────────────────────────────┤
│                                             │
│ Mutation Rate                               │
│ [===●=====] 0.01 per generation             │
│ ← Stable  |  Chaotic →                      │
│                                             │
│ Energy Availability                         │
│ [=====●===] Abundant                        │
│ ← Scarce  |  Plentiful →                    │
│                                             │
│ Reproductive Cost                           │
│ [===●=====] Moderate                        │
│ ← Cheap   |  Expensive →                    │
│                                             │
│ Environmental Pressure                      │
│ [==●======] Low                             │
│ ← Easy    |  Harsh →                        │
│                                             │
│ SPAWN RESOURCE: [Click anywhere]            │
│ SPAWN PREDATOR: [Unlocked Level 6]          │
│                                             │
└─────────────────────────────────────────────┘

TIME CONTROLS:
├─ Pause: Space
├─ Slow (0.1x): [1]
├─ Normal (1x): [2]
├─ Fast (10x): [3]
├─ Ultra (100x): [4]
└─ Hyperspeed (1000x): [5]

VIEW CONTROLS:
├─ Zoom In: Mouse Wheel Up
├─ Zoom Out: Mouse Wheel Down
├─ Pan: Click + Drag
├─ Follow Cell: Click on cell
└─ Free Camera: ESC
```

**What Emerges:**

```
Initial State:
├─ 1 cell, uniform genome
├─ Random movement
├─ Simple resource consumption
└─ Basic reproduction

After 10 generations:
├─ ~20-50 cells
├─ Slight genetic diversity
├─ Some cells faster, some slower
├─ Natural death culls inefficient cells
└─ Player notices: "They're all different!"

After 50 generations:
├─ ~100-200 cells
├─ Clear trait distributions emerging
├─ Faster cells dominate if resources spread out
├─ Larger cells dominate if resources clumped
├─ Player realizes: "The environment is selecting!"
└─ INSIGHT: Natural selection visualized

After 100 generations:
├─ Population stabilizes around carrying capacity
├─ Distinct "species" visible (color clusters)
├─ Optimal trait combinations emerge
├─ Player understands evolution
└─ Ready for Level 5
```

**Visual Design:**

```
LEVEL 4 AESTHETIC:
├─ Cells: 8x8 pixel circles
├─ Color: HSL-based (hue = genetic)
├─ Glow: Cyan life force (soft, 10px radius)
├─ Size: Varies 4-16px based on genome
├─ Motion: Brownian walk + directed movement
├─ Resources: Green squares (4x4px)
├─ Background: Dark blue-gray (#0a0e1a)
└─ UI: Minimal, non-intrusive

CELL VISUALIZATION:
     ●  ← Outer membrane (main color)
    ╱○╲ ← Inner organelles (lighter)
   ○   ○
   
   Glow intensity = energy level
   Size = genome.size trait
   Color = genome.hue + saturation
```

**Code Example: Cell Class**

```javascript
class Cell {
  constructor(genome, position, energy) {
    this.genome = genome || new Genome();
    this.position = position || {x: 400, y: 300};
    this.energy = energy || 100;
    this.generation = 0;
    this.age = 0;
    this.alive = true;
    
    // Derived from genome
    let phenotype = this.genome.getPhenotype();
    this.speed = phenotype.speed;
    this.turning = phenotype.turning;
    this.metabolicRate = phenotype.metabolism;
    this.maxEnergy = phenotype.maxEnergy;
    this.radius = phenotype.radius;
    this.color = phenotype.color;
    
    // Movement
    this.velocity = {x: 0, y: 0};
    this.direction = random(0, Math.PI * 2);
    
    // Tracking
    this.totalOffspring = 0;
    this.lifetime = 0;
  }
  
  update(deltaTime, resources, environment) {
    if (!this.alive) return;
    
    // Age
    this.age += deltaTime;
    this.lifetime += deltaTime;
    
    // Metabolism (energy drain)
    this.energy -= this.metabolicRate * deltaTime;
    
    // Death condition
    if (this.energy <= 0) {
      this.die();
      return;
    }
    
    // Movement
    this.move(deltaTime);
    
    // Feeding
    this.checkFeeding(resources);
    
    // Reproduction
    if (this.energy >= this.maxEnergy * 0.8) {
      return this.reproduce(environment.mutationRate);
    }
    
    return null;
  }
  
  move(deltaTime) {
    // Random walk (Brownian motion)
    this.direction += random(-this.turning, this.turning) * deltaTime;
    
    // Update velocity
    this.velocity.x = Math.cos(this.direction) * this.speed;
    this.velocity.y = Math.sin(this.direction) * this.speed;
    
    // Update position
    this.position.x += this.velocity.x * deltaTime;
    this.position.y += this.velocity.y * deltaTime;
    
    // Wrap around world boundaries
    if (this.position.x < 0) this.position.x += WORLD_WIDTH;
    if (this.position.x > WORLD_WIDTH) this.position.x -= WORLD_WIDTH;
    if (this.position.y < 0) this.position.y += WORLD_HEIGHT;
    if (this.position.y > WORLD_HEIGHT) this.position.y -= WORLD_HEIGHT;
  }
  
  checkFeeding(resources) {
    for (let resource of resources) {
      if (!resource.consumed) {
        let distance = this.distanceTo(resource.position);
        if (distance < this.radius + resource.radius) {
          // Eat!
          this.energy += resource.energyValue;
          this.energy = Math.min(this.energy, this.maxEnergy);
          resource.consumed = true;
          
          // Visual feedback
          effects.resourceConsumed(resource.position, this.color);
          audio.play('eat', {pitch: 1.0 + (this.radius / 16)});
        }
      }
    }
  }
  
  reproduce(mutationRate) {
    // Cost of reproduction
    let childEnergy = this.maxEnergy * 0.4;
    this.energy -= childEnergy;
    
    // Create child with mutated genome
    let childGenome = this.genome.copy();
    childGenome.mutate(mutationRate);
    
    // Spawn near parent
    let offset = randomCircle(this.radius * 2);
    let childPosition = {
      x: this.position.x + offset.x,
      y: this.position.y + offset.y
    };
    
    let child = new Cell(
      childGenome,
      childPosition,
      childEnergy
    );
    child.generation = this.generation + 1;
    
    // Tracking
    this.totalOffspring++;
    
    // Visual feedback
    effects.cellDivision(this.position, this.color);
    audio.play('reproduce', {pitch: 0.8 + (this.generation / 100)});
    
    // XP reward
    if (this.generation > gameState.maxGeneration) {
      gameState.maxGeneration = this.generation;
      xp.award(10); // XP for each new generation reached
    }
    
    return child;
  }
  
  die() {
    this.alive = false;
    
    // Become resource (recycling)
    let resource = new Resource(
      this.position,
      this.energy * 0.5 // 50% of energy becomes food
    );
    
    // Visual feedback
    effects.cellDeath(this.position, this.color);
    audio.play('death', {pitch: 0.5});
    
    // Statistics tracking
    stats.recordDeath(this);
    
    return resource;
  }
  
  distanceTo(pos) {
    let dx = pos.x - this.position.x;
    let dy = pos.y - this.position.y;
    return Math.sqrt(dx*dx + dy*dy);
  }
}
```

#### Level 5: Genetic Novice

**Goal:** Maintain stable reproducing lineage for 100 generations

**New Mechanics:**

- Genome viewer (click cell to see its genes)
- Family tree visualization (shows ancestry)
- Trait distribution graphs (show population statistics)

**Tutorial:**

```
1. "You've kept life going. Now, understand its DNA."
   
2. UI appears: GENOME VIEWER
   └─ Click any cell
   └─ Shows its complete genome:
      ┌─────────────────────────────┐
      │ GENOME                      │
      ├─────────────────────────────┤
      │ Speed:        ████████░░ 80%│
      │ Turning:      ████░░░░░░ 40%│
      │ Metabolism:   ██████░░░░ 60%│
      │ Size:         ███████░░░ 70%│
      │ Generation:   47            │
      │ Lineage:      A7→B3→C12→... │
      └─────────────────────────────┘
   
3. "Notice: children inherit parent traits"
   └─ Click parent, then child
   └─ Highlight: traits are similar but not identical
   
4. "Mutations create variation"
   └─ Show two siblings with different traits
   └─ Explain: random changes each generation
   
5. "Natural selection favors the fit"
   └─ Show population graph:
      Average Speed over Time
      │    ╱ 
      │   ╱  
      │  ╱   
      └─────────> Generations
   └─ "See? Fast cells are winning."
   
6. CHALLENGE: Keep lineage alive for 100 generations
   └─ Track one family line
   └─ Must not go extinct
   └─ Player adjusts environment to help
```

**What Emerges:**

```
Insight 1: Heritability
├─ Player sees: "Children look like parents"
├─ Understanding: Traits are inherited
└─ Foundation: Genetics makes evolution possible

Insight 2: Variation
├─ Player sees: "Every cell is unique"
├─ Understanding: Mutations create diversity
└─ Foundation: Without variation, no evolution

Insight 3: Selection
├─ Player sees: "Better cells have more children"
├─ Understanding: Fitness = survival + reproduction
└─ Foundation: Environment selects winners

Insight 4: Adaptation
├─ Player sees: Population traits shift over time
├─ Understanding: Evolution is change in population
└─ Foundation: Populations evolve, not individuals
```

**Achievement Unlock:**

```
🧬 HEREDITY BEGINS (75 XP)
└─ Maintain lineage for 100 generations
└─ Unlock: Advanced genome viewer
└─ Unlock: Trait tracking graphs
```

#### Level 6: Ecosystem Gardener

**Goal:** Create a stable food chain (producer → consumer)

**New Mechanics:**

- **Predator cells** (eat other cells)
- **Producer cells** (generate energy from light)
- **Consumer cells** (eat producers)
- **EcoForge layer unlocks** (basic ecosystem view)

**Tutorial:**

```
1. "Life needs energy. But where does it come from?"
   
2. Introduce AUTOTROPHS (producers)
   └─ Special cells that generate energy from light
   └─ New genome trait: photosynthesis = 0.0 → 1.0
   └─ Visual: Green cells with glow
   └─ Mechanic: Gain energy over time (no feeding needed)
   
3. "But some cells eat others..."
   
4. Introduce PREDATION
   └─ Predator cells (red) eat prey cells (green)
   └─ New genome trait: predator = 0.0 → 1.0
   └─ Mechanic: Collision with prey → energy transfer
   └─ Visual: Red glow, larger, faster
   
5. CHALLENGE: Balance the food chain
   └─ Too many predators → prey extinction → predator starvation
   └─ Too few predators → prey overpopulation → resource depletion
   └─ Goal: Stable oscillation for 500 generations
   
6. Show POPULATION GRAPH:
   │   ╱╲    ╱╲
   │  ╱  ╲  ╱  ╲  ← Predators (red)
   │ ╱    ╲╱    ╲
   └───────────────> Time
   │╱╲      ╱╲
   │  ╲    ╱  ╲    ← Prey (green)
   │   ╲  ╱    ╲
   └───────────────> Time
   
7. "See? They oscillate. This is ecology."
```

**Implementation: Predation System**

```javascript
class PredatorCell extends Cell {
  constructor(genome, position, energy) {
    super(genome, position, energy);
    this.isPredator = true;
    this.hungerLevel = 0;
  }
  
  update(deltaTime, prey, environment) {
    if (!this.alive) return null;
    
    // Base cell update
    super.update(deltaTime, [], environment);
    
    // Hunger increases over time
    this.hungerLevel += deltaTime;
    
    // Hunt for prey
    this.hunt(prey, deltaTime);
    
    // Reproduction (same as Cell)
    if (this.energy >= this.maxEnergy * 0.8) {
      return this.reproduce(environment.mutationRate);
    }
    
    return null;
  }
  
  hunt(preyList, deltaTime) {
    // Find nearest prey
    let nearestPrey = null;
    let nearestDistance = Infinity;
    
    for (let prey of preyList) {
      if (prey.alive) {
        let distance = this.distanceTo(prey.position);
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestPrey = prey;
        }
      }
    }
    
    // Move toward prey (if found)
    if (nearestPrey && nearestDistance < 200) {
      // Calculate direction to prey
      let dx = nearestPrey.position.x - this.position.x;
      let dy = nearestPrey.position.y - this.position.y;
      let angleToPreys = Math.atan2(dy, dx);
      
      // Turn toward prey
      let angleDiff = angleToPreys - this.direction;
      // Normalize to [-π, π]
      while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
      while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
      
      // Turn gradually
      let turnSpeed = this.turning * deltaTime;
      if (Math.abs(angleDiff) < turnSpeed) {
        this.direction = angleToPreys;
      } else {
        this.direction += Math.sign(angleDiff) * turnSpeed;
      }
      
      // Speed up when hunting
      this.velocity.x = Math.cos(this.direction) * this.speed * 1.5;
      this.velocity.y = Math.sin(this.direction) * this.speed * 1.5;
    }
    
    // Check for catch
    if (nearestPrey && nearestDistance < this.radius + nearestPrey.radius) {
      this.eat(nearestPrey);
    }
  }
  
  eat(prey) {
    // Kill prey
    prey.die();
    
    // Gain energy (with efficiency factor)
    let energyGained = prey.energy * 0.7; // 70% efficient
    this.energy += energyGained;
    this.energy = Math.min(this.energy, this.maxEnergy);
    
    // Reset hunger
    this.hungerLevel = 0;
    
    // Visual feedback
    effects.predation(this.position, prey.position);
    audio.play('predation', {volume: 0.5});
    
    // Statistics
    stats.recordPredation(this, prey);
  }
}

class ProducerCell extends Cell {
  constructor(genome, position, energy) {
    super(genome, position, energy);
    this.isProducer = true;
    this.photosynthesisRate = genome.traits.photosynthesis * 5; // 0-5 energy/sec
  }
  
  update(deltaTime, resources, environment) {
    // Base cell update
    let child = super.update(deltaTime, resources, environment);
    
    // Photosynthesis (gain energy from light)
    if (this.alive) {
      this.energy += this.photosynthesisRate * deltaTime;
      this.energy = Math.min(this.energy, this.maxEnergy);
      
      // Visual: Glow when photosynthesizing
      if (this.photosynthesisRate > 0) {
        effects.photosynthesize(this.position, this.photosynthesisRate);
      }
    }
    
    return child;
  }
}
```

**What Emerges:**

```
Early Chaos (Generations 1-50):
├─ Predators overwhelm prey
├─ Mass extinction of prey
├─ Predators starve
├─ Prey recovers
├─ Cycle repeats (unstable)
└─ Player learns: Balance is fragile

Stabilization (Generations 50-200):
├─ Oscillations dampen
├─ Predator/prey ratio stabilizes (~1:5)
├─ Faster prey survive (selection pressure)
├─ Smarter predators survive (selection pressure)
├─ Coevolution begins
└─ Player sees: Species shape each other

Stable Ecosystem (Generations 200+):
├─ Predictable oscillations
├─ Both species thrive
├─ Diversity increases (subspecies emerge)
├─ System is resilient to perturbations
└─ Player understands: Ecosystems are dynamic equilibria
```

**Achievement Unlock:**

```
🌿 FIRST FOOD CHAIN (100 XP)
└─ Stable producer-consumer relationship for 500 generations
└─ Unlock: EcoForge layer (ecosystem metrics)
└─ Unlock: Population graphs
```

---

### Phase 2: Multi-Cellularity (Levels 7-10)

#### The Leap to Cooperation

**The Challenge:** Single cells are limited. True complexity requires cooperation between cells.

**The Mechanic:**

```javascript
MULTICELLULARITY_RULES = {
  adhesion: {
    description: "Cells can stick together after division",
    trigger: "New genome trait: adhesion (0-1)",
    mechanic: "Children remain attached to parent"
  },
  
  differentiation: {
    description: "Cells in same organism can specialize",
    trigger: "Position-dependent gene expression",
    mechanic: "Edge cells ≠ center cells"
  },
  
  coordination: {
    description: "Cells in organism share energy/signals",
    trigger: "Shared resource pool",
    mechanic: "Organism acts as unit"
  },
  
  complexity: {
    description: "Multicellular organisms can evolve complex traits",
    emergent: "Organs, body plans, behaviors",
    mechanic: "New possibilities unlock"
  }
};
```

#### Level 7: Language Seed

**Goal:** Observe first communication between organisms

**New Mechanic:** **Signal System**

- Cells can emit chemical signals (pheromones)
- Other cells can detect and respond
- Foundation for language emergence

**Tutorial:**

```
1. "Cells can communicate..."
   
2. Show CHEMICAL SIGNALING
   └─ Cell A emits signal (orange pulse)
   └─ Cell B detects signal (turns toward it)
   └─ Visual: Neon trail from A to B
   
3. "This is the foundation of language."
   
4. Show emergent behaviors:
   ├─ Alarm calls (danger nearby)
   ├─ Food signals (resource found)
   ├─ Mating calls (seeking partner)
   └─ Cooperation signals (hunt together)
   
5. LinguaForge unlocks (basic layer)
   └─ Signal vocabulary tracker
   └─ Communication network display
   
6. CHALLENGE: Observe 10 successful communications
   └─ Successful = signal → response → benefit
   └─ Player rewards communication (more food near signalers)
```

**What Emerges:**

```
Simple Signals:
├─ "Danger" (red pulse when predator near)
├─ "Food" (green pulse when resource found)
├─ "Mate" (magenta pulse when seeking partner)
└─ INSIGHT: Signals convey meaning

Proto-Language:
├─ Signals become standardized
├─ Same signal = same meaning across population
├─ Vocabulary of 5-10 "words"
└─ INSIGHT: Language is social convention

Complexity:
├─ Signal combinations emerge
├─ "Food + Danger" = "Predator near food"
├─ Syntax begins to form
└─ INSIGHT: Grammar emerges from usage
```

**Achievement:**

```
🗣️ FIRST WORD (100 XP)
└─ First stable signal emerges
└─ Unlock: LinguaForge Phase 1
└─ Unlock: Communication trail visualization
```

#### Level 8: Tribal Founder

**Goal:** Form first social group (5+ organisms cooperating)

**New Mechanic:** **Social Bonds**

- Organisms remember interactions
- Repeated positive interactions → social bonds
- Groups form from bonded individuals

**Implementation:**

```javascript
class SocialCell extends Cell {
  constructor(genome, position, energy) {
    super(genome, position, energy);
    
    // Social traits
    this.socialMemory = new Map(); // other_cell → relationship_strength
    this.groupID = null;
    this.bonds = [];
    
    // Genome additions
    this.sociality = genome.traits.sociality || 0.5; // 0 = solitary, 1 = social
    this.cooperation = genome.traits.cooperation || 0.5; // 0 = selfish, 1 = altruistic
  }
  
  update(deltaTime, others, environment) {
    // Base update
    let child = super.update(deltaTime, [], environment);
    
    // Social behaviors
    if (this.alive) {
      this.socialInteractions(others, deltaTime);
      this.groupBehavior(deltaTime);
    }
    
    return child;
  }
  
  socialInteractions(others, deltaTime) {
    for (let other of others) {
      if (other === this || !other.alive) continue;
      
      let distance = this.distanceTo(other.position);
      
      // Close proximity = interaction
      if (distance < 50) {
        this.interact(other, deltaTime);
      }
    }
  }
  
  interact(other, deltaTime) {
    // Get or create relationship
    let relationship = this.socialMemory.get(other) || 0;
    
    // Positive interactions
    if (this.cooperation > 0.5) {
      // Share resources if we have excess
      if (this.energy > this.maxEnergy * 0.7 && 
          other.energy < other.maxEnergy * 0.3) {
        let share = this.maxEnergy * 0.1;
        this.energy -= share;
        other.energy += share;
        
        // Strengthen bond
        relationship += 0.1;
        
        // Visual
        effects.resourceShare(this.position, other.position);
      }
    }
    
    // Update memory
    this.socialMemory.set(other, relationship);
    
    // Form bond if relationship is strong
    if (relationship > 1.0 && !this.bonds.includes(other)) {
      this.formBond(other);
    }
  }
  
  formBond(other) {
    this.bonds.push(other);
    other.bonds.push(this);
    
    // Assign to same group
    if (this.groupID === null && other.groupID === null) {
      // New group
      let newGroupID = generateGroupID();
      this.groupID = newGroupID;
      other.groupID = newGroupID;
      
      // Track group formation
      groups.create(newGroupID, [this, other]);
      
      // Achievement check
      if (groups.get(newGroupID).length >= 5) {
        achievements.unlock('FIRST_SOCIETY');
        xp.award(100);
      }
    } else if (this.groupID !== null) {
      other.groupID = this.groupID;
      groups.add(this.groupID, other);
    } else {
      this.groupID = other.groupID;
      groups.add(other.groupID, this);
    }
    
    // Visual
    effects.bondForm(this.position, other.position, '#FF00FF');
    audio.play('bond');
  }
  
  groupBehavior(deltaTime) {
    if (this.groupID === null) return;
    
    let group = groups.get(this.groupID);
    if (!group) return;
    
    // Stay near group members
    let groupCenter = this.calculateGroupCenter(group);
    if (this.distanceTo(groupCenter) > 100) {
      // Move toward group
      let angle = Math.atan2(
        groupCenter.y - this.position.y,
        groupCenter.x - this.position.x
      );
      this.direction = angle;
    }
    
    // Synchronized movement (flocking)
    if (group.length > 3) {
      let avgDirection = this.calculateAvgDirection(group);
      this.direction = lerp(this.direction, avgDirection, 0.1);
    }
  }
  
  calculateGroupCenter(group) {
    let cx = 0, cy = 0, count = 0;
    for (let member of group) {
      if (member.alive) {
        cx += member.position.x;
        cy += member.position.y;
        count++;
      }
    }
    return {x: cx / count, y: cy / count};
  }
  
  calculateAvgDirection(group) {
    let totalX = 0, totalY = 0, count = 0;
    for (let member of group) {
      if (member.alive) {
        totalX += Math.cos(member.direction);
        totalY += Math.sin(member.direction);
        count++;
      }
    }
    return Math.atan2(totalY / count, totalX / count);
  }
}
```

**What Emerges:**

```
Individual Stage:
├─ Cells wander alone
├─ Occasional random interactions
└─ No cooperation

Pair Bonding:
├─ Two cells stay together
├─ Share resources
├─ Move in tandem
└─ Foundation of sociality

Small Groups (3-5):
├─ Multiple bonds form
├─ Individuals prefer group members
├─ Coordinated movement (flocking)
├─ Group vs individual selection
└─ INSIGHT: Cooperation has benefits

Tribes (5-20):
├─ Stable social groups
├─ Division of labor begins (some hunt, some gather)
├─ Group identity (visual markers)
├─ Defense against outsiders
└─ INSIGHT: Society is multi-individual organism
```

**Achievement:**

```
👥 SOCIETY EMERGES (100 XP)
└─ Form stable group of 5+ organisms
└─ Unlock: Social network visualizer
└─ Unlock: Group behavior controls
```

#### Level 9: Economic Basics

**Goal:** Observe division of labor and resource trading

**New Mechanics:**

- **Specialization:** Individuals focus on specific tasks
- **Trading:** Exchange of resources between specialists
- **Economy:** Emergent resource distribution system

**What Emerges:**

```
Pre-Economy:
├─ Everyone does everything
├─ Inefficient (jack of all trades, master of none)
└─ Limited productivity

Specialization:
├─ Some individuals focus on gathering
├─ Others focus on hunting
├─ Others focus on defense
└─ Each becomes better at their role

Trading:
├─ Gatherers have excess food
├─ Hunters have excess meat
├─ They exchange!
├─ Trade routes form (neon lines)
└─ INSIGHT: Specialization requires trade

Economy:
├─ Resources flow through network
├─ Supply and demand balance
├─ Wealth accumulation (some have more)
├─ First inequality emerges
└─ INSIGHT: Economics is resource flow
```

**Visual:**

```
TRADE NETWORK VISUALIZATION:
   ⬢ Gatherer (green)
   │╲
   │ ╲ (food flow)
   │  ╲
   ⬡ Hunter (red)
   │╱
   │╱ (meat flow)
   │
   △ Defender (blue)
   
Neon trails show resource exchange
Thickness = trade volume
Color = resource type
```

**Achievement:**

```
💎 FIRST ECONOMY (100 XP)
└─ Stable trade between 3+ specialists
└─ Unlock: Resource flow visualizer
└─ Unlock: CultForge layer (basic)
```

#### Level 10: Artistic Spark

**Goal:** Observe aesthetic behavior (beauty for its own sake)

**New Mechanic:** **Aesthetic Drive**

- Some organisms create patterns without survival benefit
- Beautiful displays attract mates (sexual selection)
- Art emerges as fitness indicator

**What Emerges:**

```
Functional Only:
├─ All behaviors have survival purpose
├─ No "wasted" energy
└─ Efficient but boring

Display Behavior:
├─ Some organisms make elaborate movements
├─ Colorful patterns emerge
├─ No immediate survival benefit
├─ But... attracts mates!
└─ INSIGHT: Beauty is adaptive (sexual selection)

True Art:
├─ Patterns created even without audience
├─ Seems to bring joy (dopamine reward)
├─ Passed culturally (others imitate)
├─ Becomes tradition
└─ INSIGHT: Art is human (and organism) nature
```

**Visual:**

```
AESTHETIC DISPLAY:
Organism creates spiral pattern:
          ⬡
         ╱ ╲
        ⬡   ⬡
       ╱     ╲
      ⬡   ⬡   ⬡
      
Beautiful neon trail left behind
Other organisms observe
Some imitate (cultural transmission)
```

**Achievement:**

```
🎨 ART IS BORN (100 XP)
└─ First non-functional aesthetic behavior
└─ Unlock: Beauty metrics
└─ Unlock: Cultural transmission tracker
```

---

### Phase 3: Complex Organisms (Levels 11-13)

#### Level 11: Evolutionary Guide

**Goal:** Speciate organisms for ecological niches

**Mechanic:** **Adaptive Radiation**

- Single ancestor → multiple specialized descendants
- Each subspecies adapted to different niche
- Visualize evolutionary tree

**Tutorial:**

```
1. "One species can become many."

2. Create ENVIRONMENTAL DIVERSITY:
   ├─ Forest biome (trees, shadows)
   ├─ Grassland biome (open, sunny)
   ├─ Aquatic biome (water, currents)
   └─ Desert biome (hot, scarce resources)
   
3. Release single species into diverse world
   
4. Watch over 500 generations:
   ├─ Forest dwellers evolve camouflage
   ├─ Grassland dwellers evolve speed
   ├─ Aquatic dwellers evolve streamlining
   ├─ Desert dwellers evolve water retention
   └─ Cannot interbreed anymore = speciation!
   
5. Show EVOLUTIONARY TREE:
         Common Ancestor
              /|\
             / | \
            /  |  \
         Forest Grass Aqua Desert
         Species ........
   
6. ACHIEVEMENT: 🦖 Adaptive Radiation
```

**What Emerges:**

```
Initial Diversity:
├─ Same species in different environments
├─ Slight adaptation to local conditions
└─ Still interbreed (one gene pool)

Divergence (Gen 100-300):
├─ Distinct trait combinations emerge
├─ Forest: dark, slow, large
├─ Grass: bright, fast, small
├─ Gene flow decreases (prefer own type)
└─ Populations diverging

Speciation (Gen 300-500):
├─ Reproductive isolation
├─ Cannot interbreed successfully
├─ Distinct species!
├─ Each specialized for niche
└─ INSIGHT: Geography + time = speciation
```

**Code: Speciation Detection**

```javascript
class SpeciationDetector {
  constructor() {
    this.species = [];
    this.speciationEvents = 0;
  }
  
  update(organisms) {
    // Cluster organisms by genetic similarity
    let clusters = this.geneticClustering(organisms);
    
    // Each cluster is a potential species
    for (let cluster of clusters) {
      let existing = this.findMatchingSpecies(cluster);
      
      if (existing) {
        // Update existing species
        existing.members = cluster;
      } else {
        // New species!
        let newSpecies = new Species(cluster);
        this.species.push(newSpecies);
        this.speciationEvents++;
        
        // Celebrate
        this.announceSpeciation(newSpecies);
      }
    }
    
    // Check for extinction
    this.species = this.species.filter(s => s.members.length > 0);
  }
  
  geneticClustering(organisms) {
    // K-means clustering on genome space
    let k = Math.max(1, Math.floor(organisms.length / 20));
    let clusters = kmeans(organisms, k, (a, b) => {
      return a.genome.distanceTo(b.genome);
    });
    
    return clusters;
  }
  
  findMatchingSpecies(cluster) {
    for (let species of this.species) {
      let similarity = this.clusterSimilarity(cluster, species.members);
      if (similarity > 0.8) {
        return species;
      }
    }
    return null;
  }
  
  clusterSimilarity(cluster1, cluster2) {
    // Compare cluster centroids
    let centroid1 = this.calculateCentroid(cluster1);
    let centroid2 = this.calculateCentroid(cluster2);
    
    let distance = centroid1.distanceTo(centroid2);
    return 1.0 / (1.0 + distance);
  }
  
  announceSpeciation(newSpecies) {
    ui.showMessage(`New species emerged!`);
    effects.speciation(newSpecies.members);
    audio.play('speciation');
    xp.award(250);
    
    if (this.speciationEvents >= 10) {
      achievements.unlock('ADAPTIVE_RADIATION');
    }
  }
}
```

#### Level 12: Cultural Architect

**Goal:** Develop unique societal structures in 2+ groups

**New Mechanic:** **Cultural Evolution**

- Groups develop distinct traditions
- Traditions pass from generation to generation
- Cultural identity forms

**What Emerges:**

```
Group A (Mountain Dwellers):
├─ Hierarchical (alpha leader)
├─ Aggressive (defend territory)
├─ Traditional (resist change)
└─ Architecture: Stone structures

Group B (Valley Dwellers):
├─ Egalitarian (consensus decision)
├─ Peaceful (avoid conflict)
├─ Innovative (try new things)
└─ Architecture: Organic forms

Cultural Drift:
├─ Groups become more different over time
├─ Even if genetically similar
├─ Culture shapes behavior more than genes
└─ INSIGHT: Nature AND nurture
```

**Achievement:**

```
🏛️ FIRST CIVILIZATIONS (150 XP)
└─ 2+ cultures with distinct traditions
└─ Unlock: CultForge (full layer)
└─ Unlock: Cultural trait editor
```

#### Level 13: Emergence Apprentice

**Goal:** Demonstrate cross-system interaction

**Challenge:** Language enables better hunting success

**Tutorial:**

```
1. Setup: Two groups
   ├─ Group A: High language ability, low hunting skill
   ├─ Group B: Low language ability, high hunting skill
   └─ Same environment, same prey

2. Observe over 100 generations:
   
3. Group A: 
   ├─ Develops hunting language
   ├─ "Deer left", "Circle around", etc.
   ├─ Coordination improves
   ├─ Hunting success increases!
   └─ Survives despite low initial skill

4. Group B:
   ├─ Cannot communicate well
   ├─ Hunts individually (inefficient)
   ├─ Lower success rate
   └─ Population pressure

5. Show CROSS-SYSTEM EMERGENCE:
   LinguaForge → EcoForge → NeuroForge → CultForge
   └─ Language → Hunting → Intelligence → Culture
   └─ Everything affects everything
   
6. INSIGHT: "Emergence is systemic"
   └─ You cannot understand one forge in isolation
   └─ Reality is interconnected
   └─ Mastery requires holistic thinking
```

**Achievement:**

```
⚡ SYSTEMS THINKER (200 XP)
└─ Demonstrate cross-forge interaction
└─ Unlock: Tier 2 (World Shaper)
└─ Unlock: Multi-forge visualization
```

---

### LifeForge Technical Details

#### Performance Optimization

```javascript
// Spatial hashing for efficient collision detection
class SpatialHash {
  constructor(cellSize) {
    this.cellSize = cellSize;
    this.grid = new Map();
  }
  
  clear() {
    this.grid.clear();
  }
  
  insert(entity) {
    let cells = this.getCells(entity);
    for (let cell of cells) {
      let key = this.getKey(cell.x, cell.y);
      if (!this.grid.has(key)) {
        this.grid.set(key, []);
      }
      this.grid.get(key).push(entity);
    }
  }
  
  getCells(entity) {
    // Get all cells this entity overlaps
    let minX = Math.floor((entity.position.x - entity.radius) / this.cellSize);
    let maxX = Math.floor((entity.position.x + entity.radius) / this.cellSize);
    let minY = Math.floor((entity.position.y - entity.radius) / this.cellSize);
    let maxY = Math.floor((entity.position.y + entity.radius) / this.cellSize);
    
    let cells = [];
    for (let x = minX; x <= maxX; x++) {
      for (let y = minY; y <= maxY; y++) {
        cells.push({x, y});
      }
    }
    return cells;
  }
  
  getNearby(entity) {
    let cells = this.getCells(entity);
    let nearby = new Set();
    
    for (let cell of cells) {
      let key = this.getKey(cell.x, cell.y);
      let entities = this.grid.get(key);
      if (entities) {
        for (let e of entities) {
          if (e !== entity) {
            nearby.add(e);
          }
        }
      }
    }
    
    return Array.from(nearby);
  }
  
  getKey(x, y) {
    return `${x},${y}`;
  }
}

// Object pooling for cells
class CellPool {
  constructor() {
    this.pool = [];
    this.poolSize = 1000;
    
    // Pre-allocate cells
    for (let i = 0; i < this.poolSize; i++) {
      this.pool.push(new Cell());
    }
  }
  
  acquire(genome, position, energy) {
    let cell;
    if (this.pool.length > 0) {
      cell = this.pool.pop();
      cell.reinitialize(genome, position, energy);
    } else {
      cell = new Cell(genome, position, energy);
    }
    return cell;
  }
  
  release(cell) {
    cell.reset();
    if (this.pool.length < this.poolSize) {
      this.pool.push(cell);
    }
  }
}
```

#### Rendering Optimization

```javascript
class LifeForgeRenderer {
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    
    // Offscreen canvas for entities
    this.offscreen = document.createElement('canvas');
    this.offscreen.width = canvas.width;
    this.offscreen.height = canvas.height;
    this.offscreenCtx = this.offscreen.getContext('2d');
    
    // Camera
    this.camera = {
      x: 0,
      y: 0,
      zoom: 1.0
    };
    
    // Render budget (target 60fps)
    this.maxRenderTime = 16; // milliseconds
  }
  
  render(simulation) {
    let startTime = performance.now();
    
    // Clear
    this.ctx.fillStyle = '#0a0e1a';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Apply camera transform
    this.ctx.save();
    this.ctx.translate(
      this.canvas.width / 2 - this.camera.x * this.camera.zoom,
      this.canvas.height / 2 - this.camera.y * this.camera.zoom
    );
    this.ctx.scale(this.camera.zoom, this.camera.zoom);
    
    // Frustum culling
    let visibleCells = this.frustumCull(simulation.cells);
    
    // Level of detail
    let lod = this.getLOD(visibleCells.length);
    
    // Render cells
    for (let cell of visibleCells) {
      this.renderCell(cell, lod);
      
      // Check render budget
      if (performance.now() - startTime > this.maxRenderTime) {
        break; // Skip remaining cells this frame
      }
    }
    
    // Restore transform
    this.ctx.restore();
    
    // UI (always on top)
    this.renderUI(simulation);
  }
  
  frustumCull(cells) {
    // Only render cells in viewport
    let margin = 100; // pixels outside viewport
    let left = this.camera.x - (this.canvas.width / (2 * this.camera.zoom)) - margin;
    let right = this.camera.x + (this.canvas.width / (2 * this.camera.zoom)) + margin;
    let top = this.camera.y - (this.canvas.height / (2 * this.camera.zoom)) - margin;
    let bottom = this.camera.y + (this.canvas.height / (2 * this.camera.zoom)) + margin;
    
    return cells.filter(cell => {
      return cell.position.x >= left &&
             cell.position.x <= right &&
             cell.position.y >= top &&
             cell.position.y <= bottom;
    });
  }
  
  getLOD(cellCount) {
    // Reduce detail when many cells
    if (cellCount < 100) return 'high';
    if (cellCount < 500) return 'medium';
    return 'low';
  }
  
  renderCell(cell, lod) {
    // Glow (only in high LOD)
    if (lod === 'high' && cell.energy > cell.maxEnergy * 0.3) {
      this.drawNeonGlow(
        cell.position.x,
        cell.position.y,
        cell.color,
        cell.energy / cell.maxEnergy,
        cell.radius * 1.5
      );
    }
    
    // Body
    this.ctx.fillStyle = cell.color;
    this.ctx.beginPath();
    this.ctx.arc(
      cell.position.x,
      cell.position.y,
      cell.radius,
      0, Math.PI * 2
    );
    this.ctx.fill();
    
    // Internal details (only in high LOD)
    if (lod === 'high') {
      // Nucleus
      this.ctx.fillStyle = this.lighten(cell.color, 0.3);
      this.ctx.beginPath();
      this.ctx.arc(
        cell.position.x,
        cell.position.y,
        cell.radius * 0.4,
        0, Math.PI * 2
      );
      this.ctx.fill();
      
      // Organelles
      for (let i = 0; i < 3; i++) {
        let angle = (i / 3) * Math.PI * 2;
        let x = cell.position.x + Math.cos(angle) * cell.radius * 0.6;
        let y = cell.position.y + Math.sin(angle) * cell.radius * 0.6;
        
        this.ctx.fillStyle = this.lighten(cell.color, 0.2);
        this.ctx.beginPath();
        this.ctx.arc(x, y, cell.radius * 0.2, 0, Math.PI * 2);
        this.ctx.fill();
      }
    }
  }
}
```

---
