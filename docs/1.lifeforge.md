# ğŸŒŒ FORGE COSMOS - COMPLETE DEVELOPMENT BIBLE (CONTINUED)

## ğŸ§¬ LifeForge - Cellular Evolution

### Overview

**LifeForge is where chemistry becomes biology.** Starting from the proto-cell that emerged in AtomicForge, players guide the evolution of increasingly complex life forms through the power of mutation, selection, and time.

### Design Goals

1. **Make evolution intuitive** - show it happening in real-time
2. **Demonstrate natural selection** - better-adapted organisms thrive
3. **Show the power of time** - small changes accumulate into dramatic differences
4. **Teach genetics** - traits are inherited, mutations create variation
5. **Set up multi-cellularity** - cooperation between cells unlocks complexity

### The Three Phases

```
PHASE 1: SINGLE-CELL LIFE (Levels 4-6)
â””â”€ Proto-cell â†’ Diverse single-celled organisms

PHASE 2: MULTI-CELLULARITY (Levels 7-10)
â””â”€ Cell colonies â†’ True multicellular organisms

PHASE 3: COMPLEX ORGANISMS (Levels 11-13)
â””â”€ Differentiation â†’ Organs â†’ Body plans
```

---

### Phase 1: Single-Cell Life (Levels 4-6)

#### The Rules

```javascript
CELL_RULES = {
  metabolism: {
    description: "Cells consume energy to survive",
    formula: "energy_loss = base_metabolic_rate * mass",
    mechanic: "Must eat resources or die"
  },
  
  reproduction: {
    description: "Divide when energy threshold reached",
    formula: "if (energy >= reproduction_threshold) { divide() }",
    cost: "Reproduction uses stored energy",
    mechanic: "Energy â†’ split into two cells"
  },
  
  mutation: {
    description: "Small random changes each generation",
    formula: "new_genome = parent_genome + random_mutations",
    rate: "Player-controlled slider (0.001 - 0.1 per generation)",
    mechanic: "Children differ slightly from parents"
  },
  
  death: {
    description: "Insufficient energy = cell death",
    formula: "if (energy <= 0) { die() }",
    consequences: "Dead cells become resources",
    mechanic: "Death is permanent but feeds ecosystem"
  },
  
  selection: {
    description: "Better-adapted cells survive longer",
    formula: "fitness = survival_time * offspring_count",
    emergent: "No explicit fitness function - environment selects",
    mechanic: "The environment is the judge"
  }
};
```

#### The Genome System

```javascript
class Genome {
  constructor() {
    // Traits encoded as real numbers (0-1)
    this.traits = {
      // Movement
      speed: 0.5,              // 0 = slow, 1 = fast
      turning_rate: 0.5,       // 0 = straight, 1 = erratic
      
      // Metabolism
      metabolic_rate: 0.5,     // 0 = efficient, 1 = hungry
      energy_storage: 0.5,     // 0 = small reserve, 1 = large
      
      // Size
      size: 0.5,               // 0 = tiny, 1 = large
      
      // Senses (unlocked later)
      light_sensitivity: 0.0,  // 0 = blind, 1 = photosensitive
      chemical_sensitivity: 0.0, // 0 = oblivious, 1 = chemotaxis
      
      // Reproduction
      reproduction_threshold: 0.5, // 0 = reproduce quickly, 1 = save energy
      offspring_count: 0.0,    // 0 = one child, 1 = multiple (budding)
      
      // Defense (unlocked later)
      armor: 0.0,              // 0 = fragile, 1 = tough
      toxin: 0.0,              // 0 = harmless, 1 = poisonous
      
      // Color (cosmetic, but affects predation later)
      hue: random(0, 360),     // HSL hue value
      saturation: 0.5,         // 0 = gray, 1 = vibrant
    };
  }
  
  mutate(mutationRate) {
    for (let trait in this.traits) {
      if (Math.random() < mutationRate) {
        // Gaussian mutation: small changes most common
        let change = this.gaussianRandom(0, 0.1);
        this.traits[trait] += change;
        
        // Clamp to valid range
        this.traits[trait] = Math.max(0, Math.min(1, this.traits[trait]));
      }
    }
    
    // Color mutation is special (wraps around)
    if (Math.random() < mutationRate) {
      this.traits.hue = (this.traits.hue + this.gaussianRandom(0, 30)) % 360;
    }
  }
  
  gaussianRandom(mean, stdDev) {
    // Box-Muller transform for Gaussian distribution
    let u1 = Math.random();
    let u2 = Math.random();
    let z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    return mean + stdDev * z0;
  }
  
  // Phenotype expression: genome â†’ visible traits
  getPhenotype() {
    return {
      speed: this.traits.speed * 100, // 0-100 pixels/sec
      turning: this.traits.turning_rate * Math.PI, // 0-180 degrees/sec
      metabolism: 1 + (this.traits.metabolic_rate * 2), // 1-3 energy/sec
      maxEnergy: 50 + (this.traits.energy_storage * 150), // 50-200 energy
      radius: 4 + (this.traits.size * 12), // 4-16 pixels
      color: this.getColor()
    };
  }
  
  getColor() {
    return `hsl(${this.traits.hue}, ${this.traits.saturation * 100}%, 50%)`;
  }
}
```

#### Level 4: Cellular Architect

**Goal:** Keep your first cell alive and reproducing

**Tutorial Flow:**

```
1. FADE IN from AtomicForge
   â””â”€ Proto-cell in center of screen, pulsing
   
2. "This is life."
   â””â”€ Cell glows with cyan life force
   
3. "It needs energy."
   â””â”€ Green resource particles appear nearby
   â””â”€ Cell slowly drifts toward them (random walk)
   
4. Cell touches resource
   â””â”€ Resource disappears
   â””â”€ Cell's energy increases (visible meter)
   â””â”€ "Good. It's feeding."
   
5. Energy fills up
   â””â”€ Cell grows slightly larger
   â””â”€ "When energy is full, it will divide."
   
6. Cell reaches threshold
   â””â”€ Division animation:
      â—  â†’  â— â—  (splits into two)
   â””â”€ ACHIEVEMENT UNLOCKED: ğŸ£ Genesis Event
   
7. Two cells now exist
   â””â”€ Each has slightly different genome (mutation)
   â””â”€ "Life has begun to evolve."
   
8. UI fades in
   â””â”€ Show energy meters for all cells
   â””â”€ Show generation counter
   â””â”€ Show mutation rate slider
   
9. "Your task: Guide its evolution."
   â””â”€ Tutorial ends
   â””â”€ Player now in control
```

**Player Controls:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ LIFEFORGE CONTROLS                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                             â”‚
â”‚ Mutation Rate                               â”‚
â”‚ [===â—=====] 0.01 per generation             â”‚
â”‚ â† Stable  |  Chaotic â†’                      â”‚
â”‚                                             â”‚
â”‚ Energy Availability                         â”‚
â”‚ [=====â—===] Abundant                        â”‚
â”‚ â† Scarce  |  Plentiful â†’                    â”‚
â”‚                                             â”‚
â”‚ Reproductive Cost                           â”‚
â”‚ [===â—=====] Moderate                        â”‚
â”‚ â† Cheap   |  Expensive â†’                    â”‚
â”‚                                             â”‚
â”‚ Environmental Pressure                      â”‚
â”‚ [==â—======] Low                             â”‚
â”‚ â† Easy    |  Harsh â†’                        â”‚
â”‚                                             â”‚
â”‚ SPAWN RESOURCE: [Click anywhere]            â”‚
â”‚ SPAWN PREDATOR: [Unlocked Level 6]          â”‚
â”‚                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

TIME CONTROLS:
â”œâ”€ Pause: Space
â”œâ”€ Slow (0.1x): [1]
â”œâ”€ Normal (1x): [2]
â”œâ”€ Fast (10x): [3]
â”œâ”€ Ultra (100x): [4]
â””â”€ Hyperspeed (1000x): [5]

VIEW CONTROLS:
â”œâ”€ Zoom In: Mouse Wheel Up
â”œâ”€ Zoom Out: Mouse Wheel Down
â”œâ”€ Pan: Click + Drag
â”œâ”€ Follow Cell: Click on cell
â””â”€ Free Camera: ESC
```

**What Emerges:**

```
Initial State:
â”œâ”€ 1 cell, uniform genome
â”œâ”€ Random movement
â”œâ”€ Simple resource consumption
â””â”€ Basic reproduction

After 10 generations:
â”œâ”€ ~20-50 cells
â”œâ”€ Slight genetic diversity
â”œâ”€ Some cells faster, some slower
â”œâ”€ Natural death culls inefficient cells
â””â”€ Player notices: "They're all different!"

After 50 generations:
â”œâ”€ ~100-200 cells
â”œâ”€ Clear trait distributions emerging
â”œâ”€ Faster cells dominate if resources spread out
â”œâ”€ Larger cells dominate if resources clumped
â”œâ”€ Player realizes: "The environment is selecting!"
â””â”€ INSIGHT: Natural selection visualized

After 100 generations:
â”œâ”€ Population stabilizes around carrying capacity
â”œâ”€ Distinct "species" visible (color clusters)
â”œâ”€ Optimal trait combinations emerge
â”œâ”€ Player understands evolution
â””â”€ Ready for Level 5
```

**Visual Design:**

```
LEVEL 4 AESTHETIC:
â”œâ”€ Cells: 8x8 pixel circles
â”œâ”€ Color: HSL-based (hue = genetic)
â”œâ”€ Glow: Cyan life force (soft, 10px radius)
â”œâ”€ Size: Varies 4-16px based on genome
â”œâ”€ Motion: Brownian walk + directed movement
â”œâ”€ Resources: Green squares (4x4px)
â”œâ”€ Background: Dark blue-gray (#0a0e1a)
â””â”€ UI: Minimal, non-intrusive

CELL VISUALIZATION:
     â—  â† Outer membrane (main color)
    â•±â—‹â•² â† Inner organelles (lighter)
   â—‹   â—‹
   
   Glow intensity = energy level
   Size = genome.size trait
   Color = genome.hue + saturation
```

**Code Example: Cell Class**

```javascript
class Cell {
  constructor(genome, position, energy) {
    this.genome = genome || new Genome();
    this.position = position || {x: 400, y: 300};
    this.energy = energy || 100;
    this.generation = 0;
    this.age = 0;
    this.alive = true;
    
    // Derived from genome
    let phenotype = this.genome.getPhenotype();
    this.speed = phenotype.speed;
    this.turning = phenotype.turning;
    this.metabolicRate = phenotype.metabolism;
    this.maxEnergy = phenotype.maxEnergy;
    this.radius = phenotype.radius;
    this.color = phenotype.color;
    
    // Movement
    this.velocity = {x: 0, y: 0};
    this.direction = random(0, Math.PI * 2);
    
    // Tracking
    this.totalOffspring = 0;
    this.lifetime = 0;
  }
  
  update(deltaTime, resources, environment) {
    if (!this.alive) return;
    
    // Age
    this.age += deltaTime;
    this.lifetime += deltaTime;
    
    // Metabolism (energy drain)
    this.energy -= this.metabolicRate * deltaTime;
    
    // Death condition
    if (this.energy <= 0) {
      this.die();
      return;
    }
    
    // Movement
    this.move(deltaTime);
    
    // Feeding
    this.checkFeeding(resources);
    
    // Reproduction
    if (this.energy >= this.maxEnergy * 0.8) {
      return this.reproduce(environment.mutationRate);
    }
    
    return null;
  }
  
  move(deltaTime) {
    // Random walk (Brownian motion)
    this.direction += random(-this.turning, this.turning) * deltaTime;
    
    // Update velocity
    this.velocity.x = Math.cos(this.direction) * this.speed;
    this.velocity.y = Math.sin(this.direction) * this.speed;
    
    // Update position
    this.position.x += this.velocity.x * deltaTime;
    this.position.y += this.velocity.y * deltaTime;
    
    // Wrap around world boundaries
    if (this.position.x < 0) this.position.x += WORLD_WIDTH;
    if (this.position.x > WORLD_WIDTH) this.position.x -= WORLD_WIDTH;
    if (this.position.y < 0) this.position.y += WORLD_HEIGHT;
    if (this.position.y > WORLD_HEIGHT) this.position.y -= WORLD_HEIGHT;
  }
  
  checkFeeding(resources) {
    for (let resource of resources) {
      if (!resource.consumed) {
        let distance = this.distanceTo(resource.position);
        if (distance < this.radius + resource.radius) {
          // Eat!
          this.energy += resource.energyValue;
          this.energy = Math.min(this.energy, this.maxEnergy);
          resource.consumed = true;
          
          // Visual feedback
          effects.resourceConsumed(resource.position, this.color);
          audio.play('eat', {pitch: 1.0 + (this.radius / 16)});
        }
      }
    }
  }
  
  reproduce(mutationRate) {
    // Cost of reproduction
    let childEnergy = this.maxEnergy * 0.4;
    this.energy -= childEnergy;
    
    // Create child with mutated genome
    let childGenome = this.genome.copy();
    childGenome.mutate(mutationRate);
    
    // Spawn near parent
    let offset = randomCircle(this.radius * 2);
    let childPosition = {
      x: this.position.x + offset.x,
      y: this.position.y + offset.y
    };
    
    let child = new Cell(
      childGenome,
      childPosition,
      childEnergy
    );
    child.generation = this.generation + 1;
    
    // Tracking
    this.totalOffspring++;
    
    // Visual feedback
    effects.cellDivision(this.position, this.color);
    audio.play('reproduce', {pitch: 0.8 + (this.generation / 100)});
    
    // XP reward
    if (this.generation > gameState.maxGeneration) {
      gameState.maxGeneration = this.generation;
      xp.award(10); // XP for each new generation reached
    }
    
    return child;
  }
  
  die() {
    this.alive = false;
    
    // Become resource (recycling)
    let resource = new Resource(
      this.position,
      this.energy * 0.5 // 50% of energy becomes food
    );
    
    // Visual feedback
    effects.cellDeath(this.position, this.color);
    audio.play('death', {pitch: 0.5});
    
    // Statistics tracking
    stats.recordDeath(this);
    
    return resource;
  }
  
  distanceTo(pos) {
    let dx = pos.x - this.position.x;
    let dy = pos.y - this.position.y;
    return Math.sqrt(dx*dx + dy*dy);
  }
}
```

#### Level 5: Genetic Novice

**Goal:** Maintain stable reproducing lineage for 100 generations

**New Mechanics:**

- Genome viewer (click cell to see its genes)
- Family tree visualization (shows ancestry)
- Trait distribution graphs (show population statistics)

**Tutorial:**

```
1. "You've kept life going. Now, understand its DNA."
   
2. UI appears: GENOME VIEWER
   â””â”€ Click any cell
   â””â”€ Shows its complete genome:
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ GENOME                      â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚ Speed:        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘ 80%â”‚
      â”‚ Turning:      â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘ 40%â”‚
      â”‚ Metabolism:   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘ 60%â”‚
      â”‚ Size:         â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘ 70%â”‚
      â”‚ Generation:   47            â”‚
      â”‚ Lineage:      A7â†’B3â†’C12â†’... â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   
3. "Notice: children inherit parent traits"
   â””â”€ Click parent, then child
   â””â”€ Highlight: traits are similar but not identical
   
4. "Mutations create variation"
   â””â”€ Show two siblings with different traits
   â””â”€ Explain: random changes each generation
   
5. "Natural selection favors the fit"
   â””â”€ Show population graph:
      Average Speed over Time
      â”‚    â•± 
      â”‚   â•±  
      â”‚  â•±   
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€> Generations
   â””â”€ "See? Fast cells are winning."
   
6. CHALLENGE: Keep lineage alive for 100 generations
   â””â”€ Track one family line
   â””â”€ Must not go extinct
   â””â”€ Player adjusts environment to help
```

**What Emerges:**

```
Insight 1: Heritability
â”œâ”€ Player sees: "Children look like parents"
â”œâ”€ Understanding: Traits are inherited
â””â”€ Foundation: Genetics makes evolution possible

Insight 2: Variation
â”œâ”€ Player sees: "Every cell is unique"
â”œâ”€ Understanding: Mutations create diversity
â””â”€ Foundation: Without variation, no evolution

Insight 3: Selection
â”œâ”€ Player sees: "Better cells have more children"
â”œâ”€ Understanding: Fitness = survival + reproduction
â””â”€ Foundation: Environment selects winners

Insight 4: Adaptation
â”œâ”€ Player sees: Population traits shift over time
â”œâ”€ Understanding: Evolution is change in population
â””â”€ Foundation: Populations evolve, not individuals
```

**Achievement Unlock:**

```
ğŸ§¬ HEREDITY BEGINS (75 XP)
â””â”€ Maintain lineage for 100 generations
â””â”€ Unlock: Advanced genome viewer
â””â”€ Unlock: Trait tracking graphs
```

#### Level 6: Ecosystem Gardener

**Goal:** Create a stable food chain (producer â†’ consumer)

**New Mechanics:**

- **Predator cells** (eat other cells)
- **Producer cells** (generate energy from light)
- **Consumer cells** (eat producers)
- **EcoForge layer unlocks** (basic ecosystem view)

**Tutorial:**

```
1. "Life needs energy. But where does it come from?"
   
2. Introduce AUTOTROPHS (producers)
   â””â”€ Special cells that generate energy from light
   â””â”€ New genome trait: photosynthesis = 0.0 â†’ 1.0
   â””â”€ Visual: Green cells with glow
   â””â”€ Mechanic: Gain energy over time (no feeding needed)
   
3. "But some cells eat others..."
   
4. Introduce PREDATION
   â””â”€ Predator cells (red) eat prey cells (green)
   â””â”€ New genome trait: predator = 0.0 â†’ 1.0
   â””â”€ Mechanic: Collision with prey â†’ energy transfer
   â””â”€ Visual: Red glow, larger, faster
   
5. CHALLENGE: Balance the food chain
   â””â”€ Too many predators â†’ prey extinction â†’ predator starvation
   â””â”€ Too few predators â†’ prey overpopulation â†’ resource depletion
   â””â”€ Goal: Stable oscillation for 500 generations
   
6. Show POPULATION GRAPH:
   â”‚   â•±â•²    â•±â•²
   â”‚  â•±  â•²  â•±  â•²  â† Predators (red)
   â”‚ â•±    â•²â•±    â•²
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Time
   â”‚â•±â•²      â•±â•²
   â”‚  â•²    â•±  â•²    â† Prey (green)
   â”‚   â•²  â•±    â•²
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Time
   
7. "See? They oscillate. This is ecology."
```

**Implementation: Predation System**

```javascript
class PredatorCell extends Cell {
  constructor(genome, position, energy) {
    super(genome, position, energy);
    this.isPredator = true;
    this.hungerLevel = 0;
  }
  
  update(deltaTime, prey, environment) {
    if (!this.alive) return null;
    
    // Base cell update
    super.update(deltaTime, [], environment);
    
    // Hunger increases over time
    this.hungerLevel += deltaTime;
    
    // Hunt for prey
    this.hunt(prey, deltaTime);
    
    // Reproduction (same as Cell)
    if (this.energy >= this.maxEnergy * 0.8) {
      return this.reproduce(environment.mutationRate);
    }
    
    return null;
  }
  
  hunt(preyList, deltaTime) {
    // Find nearest prey
    let nearestPrey = null;
    let nearestDistance = Infinity;
    
    for (let prey of preyList) {
      if (prey.alive) {
        let distance = this.distanceTo(prey.position);
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestPrey = prey;
        }
      }
    }
    
    // Move toward prey (if found)
    if (nearestPrey && nearestDistance < 200) {
      // Calculate direction to prey
      let dx = nearestPrey.position.x - this.position.x;
      let dy = nearestPrey.position.y - this.position.y;
      let angleToPreys = Math.atan2(dy, dx);
      
      // Turn toward prey
      let angleDiff = angleToPreys - this.direction;
      // Normalize to [-Ï€, Ï€]
      while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
      while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
      
      // Turn gradually
      let turnSpeed = this.turning * deltaTime;
      if (Math.abs(angleDiff) < turnSpeed) {
        this.direction = angleToPreys;
      } else {
        this.direction += Math.sign(angleDiff) * turnSpeed;
      }
      
      // Speed up when hunting
      this.velocity.x = Math.cos(this.direction) * this.speed * 1.5;
      this.velocity.y = Math.sin(this.direction) * this.speed * 1.5;
    }
    
    // Check for catch
    if (nearestPrey && nearestDistance < this.radius + nearestPrey.radius) {
      this.eat(nearestPrey);
    }
  }
  
  eat(prey) {
    // Kill prey
    prey.die();
    
    // Gain energy (with efficiency factor)
    let energyGained = prey.energy * 0.7; // 70% efficient
    this.energy += energyGained;
    this.energy = Math.min(this.energy, this.maxEnergy);
    
    // Reset hunger
    this.hungerLevel = 0;
    
    // Visual feedback
    effects.predation(this.position, prey.position);
    audio.play('predation', {volume: 0.5});
    
    // Statistics
    stats.recordPredation(this, prey);
  }
}

class ProducerCell extends Cell {
  constructor(genome, position, energy) {
    super(genome, position, energy);
    this.isProducer = true;
    this.photosynthesisRate = genome.traits.photosynthesis * 5; // 0-5 energy/sec
  }
  
  update(deltaTime, resources, environment) {
    // Base cell update
    let child = super.update(deltaTime, resources, environment);
    
    // Photosynthesis (gain energy from light)
    if (this.alive) {
      this.energy += this.photosynthesisRate * deltaTime;
      this.energy = Math.min(this.energy, this.maxEnergy);
      
      // Visual: Glow when photosynthesizing
      if (this.photosynthesisRate > 0) {
        effects.photosynthesize(this.position, this.photosynthesisRate);
      }
    }
    
    return child;
  }
}
```

**What Emerges:**

```
Early Chaos (Generations 1-50):
â”œâ”€ Predators overwhelm prey
â”œâ”€ Mass extinction of prey
â”œâ”€ Predators starve
â”œâ”€ Prey recovers
â”œâ”€ Cycle repeats (unstable)
â””â”€ Player learns: Balance is fragile

Stabilization (Generations 50-200):
â”œâ”€ Oscillations dampen
â”œâ”€ Predator/prey ratio stabilizes (~1:5)
â”œâ”€ Faster prey survive (selection pressure)
â”œâ”€ Smarter predators survive (selection pressure)
â”œâ”€ Coevolution begins
â””â”€ Player sees: Species shape each other

Stable Ecosystem (Generations 200+):
â”œâ”€ Predictable oscillations
â”œâ”€ Both species thrive
â”œâ”€ Diversity increases (subspecies emerge)
â”œâ”€ System is resilient to perturbations
â””â”€ Player understands: Ecosystems are dynamic equilibria
```

**Achievement Unlock:**

```
ğŸŒ¿ FIRST FOOD CHAIN (100 XP)
â””â”€ Stable producer-consumer relationship for 500 generations
â””â”€ Unlock: EcoForge layer (ecosystem metrics)
â””â”€ Unlock: Population graphs
```

---

### Phase 2: Multi-Cellularity (Levels 7-10)

#### The Leap to Cooperation

**The Challenge:** Single cells are limited. True complexity requires cooperation between cells.

**The Mechanic:**

```javascript
MULTICELLULARITY_RULES = {
  adhesion: {
    description: "Cells can stick together after division",
    trigger: "New genome trait: adhesion (0-1)",
    mechanic: "Children remain attached to parent"
  },
  
  differentiation: {
    description: "Cells in same organism can specialize",
    trigger: "Position-dependent gene expression",
    mechanic: "Edge cells â‰  center cells"
  },
  
  coordination: {
    description: "Cells in organism share energy/signals",
    trigger: "Shared resource pool",
    mechanic: "Organism acts as unit"
  },
  
  complexity: {
    description: "Multicellular organisms can evolve complex traits",
    emergent: "Organs, body plans, behaviors",
    mechanic: "New possibilities unlock"
  }
};
```

#### Level 7: Language Seed

**Goal:** Observe first communication between organisms

**New Mechanic:** **Signal System**

- Cells can emit chemical signals (pheromones)
- Other cells can detect and respond
- Foundation for language emergence

**Tutorial:**

```
1. "Cells can communicate..."
   
2. Show CHEMICAL SIGNALING
   â””â”€ Cell A emits signal (orange pulse)
   â””â”€ Cell B detects signal (turns toward it)
   â””â”€ Visual: Neon trail from A to B
   
3. "This is the foundation of language."
   
4. Show emergent behaviors:
   â”œâ”€ Alarm calls (danger nearby)
   â”œâ”€ Food signals (resource found)
   â”œâ”€ Mating calls (seeking partner)
   â””â”€ Cooperation signals (hunt together)
   
5. LinguaForge unlocks (basic layer)
   â””â”€ Signal vocabulary tracker
   â””â”€ Communication network display
   
6. CHALLENGE: Observe 10 successful communications
   â””â”€ Successful = signal â†’ response â†’ benefit
   â””â”€ Player rewards communication (more food near signalers)
```

**What Emerges:**

```
Simple Signals:
â”œâ”€ "Danger" (red pulse when predator near)
â”œâ”€ "Food" (green pulse when resource found)
â”œâ”€ "Mate" (magenta pulse when seeking partner)
â””â”€ INSIGHT: Signals convey meaning

Proto-Language:
â”œâ”€ Signals become standardized
â”œâ”€ Same signal = same meaning across population
â”œâ”€ Vocabulary of 5-10 "words"
â””â”€ INSIGHT: Language is social convention

Complexity:
â”œâ”€ Signal combinations emerge
â”œâ”€ "Food + Danger" = "Predator near food"
â”œâ”€ Syntax begins to form
â””â”€ INSIGHT: Grammar emerges from usage
```

**Achievement:**

```
ğŸ—£ï¸ FIRST WORD (100 XP)
â””â”€ First stable signal emerges
â””â”€ Unlock: LinguaForge Phase 1
â””â”€ Unlock: Communication trail visualization
```

#### Level 8: Tribal Founder

**Goal:** Form first social group (5+ organisms cooperating)

**New Mechanic:** **Social Bonds**

- Organisms remember interactions
- Repeated positive interactions â†’ social bonds
- Groups form from bonded individuals

**Implementation:**

```javascript
class SocialCell extends Cell {
  constructor(genome, position, energy) {
    super(genome, position, energy);
    
    // Social traits
    this.socialMemory = new Map(); // other_cell â†’ relationship_strength
    this.groupID = null;
    this.bonds = [];
    
    // Genome additions
    this.sociality = genome.traits.sociality || 0.5; // 0 = solitary, 1 = social
    this.cooperation = genome.traits.cooperation || 0.5; // 0 = selfish, 1 = altruistic
  }
  
  update(deltaTime, others, environment) {
    // Base update
    let child = super.update(deltaTime, [], environment);
    
    // Social behaviors
    if (this.alive) {
      this.socialInteractions(others, deltaTime);
      this.groupBehavior(deltaTime);
    }
    
    return child;
  }
  
  socialInteractions(others, deltaTime) {
    for (let other of others) {
      if (other === this || !other.alive) continue;
      
      let distance = this.distanceTo(other.position);
      
      // Close proximity = interaction
      if (distance < 50) {
        this.interact(other, deltaTime);
      }
    }
  }
  
  interact(other, deltaTime) {
    // Get or create relationship
    let relationship = this.socialMemory.get(other) || 0;
    
    // Positive interactions
    if (this.cooperation > 0.5) {
      // Share resources if we have excess
      if (this.energy > this.maxEnergy * 0.7 && 
          other.energy < other.maxEnergy * 0.3) {
        let share = this.maxEnergy * 0.1;
        this.energy -= share;
        other.energy += share;
        
        // Strengthen bond
        relationship += 0.1;
        
        // Visual
        effects.resourceShare(this.position, other.position);
      }
    }
    
    // Update memory
    this.socialMemory.set(other, relationship);
    
    // Form bond if relationship is strong
    if (relationship > 1.0 && !this.bonds.includes(other)) {
      this.formBond(other);
    }
  }
  
  formBond(other) {
    this.bonds.push(other);
    other.bonds.push(this);
    
    // Assign to same group
    if (this.groupID === null && other.groupID === null) {
      // New group
      let newGroupID = generateGroupID();
      this.groupID = newGroupID;
      other.groupID = newGroupID;
      
      // Track group formation
      groups.create(newGroupID, [this, other]);
      
      // Achievement check
      if (groups.get(newGroupID).length >= 5) {
        achievements.unlock('FIRST_SOCIETY');
        xp.award(100);
      }
    } else if (this.groupID !== null) {
      other.groupID = this.groupID;
      groups.add(this.groupID, other);
    } else {
      this.groupID = other.groupID;
      groups.add(other.groupID, this);
    }
    
    // Visual
    effects.bondForm(this.position, other.position, '#FF00FF');
    audio.play('bond');
  }
  
  groupBehavior(deltaTime) {
    if (this.groupID === null) return;
    
    let group = groups.get(this.groupID);
    if (!group) return;
    
    // Stay near group members
    let groupCenter = this.calculateGroupCenter(group);
    if (this.distanceTo(groupCenter) > 100) {
      // Move toward group
      let angle = Math.atan2(
        groupCenter.y - this.position.y,
        groupCenter.x - this.position.x
      );
      this.direction = angle;
    }
    
    // Synchronized movement (flocking)
    if (group.length > 3) {
      let avgDirection = this.calculateAvgDirection(group);
      this.direction = lerp(this.direction, avgDirection, 0.1);
    }
  }
  
  calculateGroupCenter(group) {
    let cx = 0, cy = 0, count = 0;
    for (let member of group) {
      if (member.alive) {
        cx += member.position.x;
        cy += member.position.y;
        count++;
      }
    }
    return {x: cx / count, y: cy / count};
  }
  
  calculateAvgDirection(group) {
    let totalX = 0, totalY = 0, count = 0;
    for (let member of group) {
      if (member.alive) {
        totalX += Math.cos(member.direction);
        totalY += Math.sin(member.direction);
        count++;
      }
    }
    return Math.atan2(totalY / count, totalX / count);
  }
}
```

**What Emerges:**

```
Individual Stage:
â”œâ”€ Cells wander alone
â”œâ”€ Occasional random interactions
â””â”€ No cooperation

Pair Bonding:
â”œâ”€ Two cells stay together
â”œâ”€ Share resources
â”œâ”€ Move in tandem
â””â”€ Foundation of sociality

Small Groups (3-5):
â”œâ”€ Multiple bonds form
â”œâ”€ Individuals prefer group members
â”œâ”€ Coordinated movement (flocking)
â”œâ”€ Group vs individual selection
â””â”€ INSIGHT: Cooperation has benefits

Tribes (5-20):
â”œâ”€ Stable social groups
â”œâ”€ Division of labor begins (some hunt, some gather)
â”œâ”€ Group identity (visual markers)
â”œâ”€ Defense against outsiders
â””â”€ INSIGHT: Society is multi-individual organism
```

**Achievement:**

```
ğŸ‘¥ SOCIETY EMERGES (100 XP)
â””â”€ Form stable group of 5+ organisms
â””â”€ Unlock: Social network visualizer
â””â”€ Unlock: Group behavior controls
```

#### Level 9: Economic Basics

**Goal:** Observe division of labor and resource trading

**New Mechanics:**

- **Specialization:** Individuals focus on specific tasks
- **Trading:** Exchange of resources between specialists
- **Economy:** Emergent resource distribution system

**What Emerges:**

```
Pre-Economy:
â”œâ”€ Everyone does everything
â”œâ”€ Inefficient (jack of all trades, master of none)
â””â”€ Limited productivity

Specialization:
â”œâ”€ Some individuals focus on gathering
â”œâ”€ Others focus on hunting
â”œâ”€ Others focus on defense
â””â”€ Each becomes better at their role

Trading:
â”œâ”€ Gatherers have excess food
â”œâ”€ Hunters have excess meat
â”œâ”€ They exchange!
â”œâ”€ Trade routes form (neon lines)
â””â”€ INSIGHT: Specialization requires trade

Economy:
â”œâ”€ Resources flow through network
â”œâ”€ Supply and demand balance
â”œâ”€ Wealth accumulation (some have more)
â”œâ”€ First inequality emerges
â””â”€ INSIGHT: Economics is resource flow
```

**Visual:**

```
TRADE NETWORK VISUALIZATION:
   â¬¢ Gatherer (green)
   â”‚â•²
   â”‚ â•² (food flow)
   â”‚  â•²
   â¬¡ Hunter (red)
   â”‚â•±
   â”‚â•± (meat flow)
   â”‚
   â–³ Defender (blue)
   
Neon trails show resource exchange
Thickness = trade volume
Color = resource type
```

**Achievement:**

```
ğŸ’ FIRST ECONOMY (100 XP)
â””â”€ Stable trade between 3+ specialists
â””â”€ Unlock: Resource flow visualizer
â””â”€ Unlock: CultForge layer (basic)
```

#### Level 10: Artistic Spark

**Goal:** Observe aesthetic behavior (beauty for its own sake)

**New Mechanic:** **Aesthetic Drive**

- Some organisms create patterns without survival benefit
- Beautiful displays attract mates (sexual selection)
- Art emerges as fitness indicator

**What Emerges:**

```
Functional Only:
â”œâ”€ All behaviors have survival purpose
â”œâ”€ No "wasted" energy
â””â”€ Efficient but boring

Display Behavior:
â”œâ”€ Some organisms make elaborate movements
â”œâ”€ Colorful patterns emerge
â”œâ”€ No immediate survival benefit
â”œâ”€ But... attracts mates!
â””â”€ INSIGHT: Beauty is adaptive (sexual selection)

True Art:
â”œâ”€ Patterns created even without audience
â”œâ”€ Seems to bring joy (dopamine reward)
â”œâ”€ Passed culturally (others imitate)
â”œâ”€ Becomes tradition
â””â”€ INSIGHT: Art is human (and organism) nature
```

**Visual:**

```
AESTHETIC DISPLAY:
Organism creates spiral pattern:
          â¬¡
         â•± â•²
        â¬¡   â¬¡
       â•±     â•²
      â¬¡   â¬¡   â¬¡
      
Beautiful neon trail left behind
Other organisms observe
Some imitate (cultural transmission)
```

**Achievement:**

```
ğŸ¨ ART IS BORN (100 XP)
â””â”€ First non-functional aesthetic behavior
â””â”€ Unlock: Beauty metrics
â””â”€ Unlock: Cultural transmission tracker
```

---

### Phase 3: Complex Organisms (Levels 11-13)

#### Level 11: Evolutionary Guide

**Goal:** Speciate organisms for ecological niches

**Mechanic:** **Adaptive Radiation**

- Single ancestor â†’ multiple specialized descendants
- Each subspecies adapted to different niche
- Visualize evolutionary tree

**Tutorial:**

```
1. "One species can become many."

2. Create ENVIRONMENTAL DIVERSITY:
   â”œâ”€ Forest biome (trees, shadows)
   â”œâ”€ Grassland biome (open, sunny)
   â”œâ”€ Aquatic biome (water, currents)
   â””â”€ Desert biome (hot, scarce resources)
   
3. Release single species into diverse world
   
4. Watch over 500 generations:
   â”œâ”€ Forest dwellers evolve camouflage
   â”œâ”€ Grassland dwellers evolve speed
   â”œâ”€ Aquatic dwellers evolve streamlining
   â”œâ”€ Desert dwellers evolve water retention
   â””â”€ Cannot interbreed anymore = speciation!
   
5. Show EVOLUTIONARY TREE:
         Common Ancestor
              /|\
             / | \
            /  |  \
         Forest Grass Aqua Desert
         Species ........
   
6. ACHIEVEMENT: ğŸ¦– Adaptive Radiation
```

**What Emerges:**

```
Initial Diversity:
â”œâ”€ Same species in different environments
â”œâ”€ Slight adaptation to local conditions
â””â”€ Still interbreed (one gene pool)

Divergence (Gen 100-300):
â”œâ”€ Distinct trait combinations emerge
â”œâ”€ Forest: dark, slow, large
â”œâ”€ Grass: bright, fast, small
â”œâ”€ Gene flow decreases (prefer own type)
â””â”€ Populations diverging

Speciation (Gen 300-500):
â”œâ”€ Reproductive isolation
â”œâ”€ Cannot interbreed successfully
â”œâ”€ Distinct species!
â”œâ”€ Each specialized for niche
â””â”€ INSIGHT: Geography + time = speciation
```

**Code: Speciation Detection**

```javascript
class SpeciationDetector {
  constructor() {
    this.species = [];
    this.speciationEvents = 0;
  }
  
  update(organisms) {
    // Cluster organisms by genetic similarity
    let clusters = this.geneticClustering(organisms);
    
    // Each cluster is a potential species
    for (let cluster of clusters) {
      let existing = this.findMatchingSpecies(cluster);
      
      if (existing) {
        // Update existing species
        existing.members = cluster;
      } else {
        // New species!
        let newSpecies = new Species(cluster);
        this.species.push(newSpecies);
        this.speciationEvents++;
        
        // Celebrate
        this.announceSpeciation(newSpecies);
      }
    }
    
    // Check for extinction
    this.species = this.species.filter(s => s.members.length > 0);
  }
  
  geneticClustering(organisms) {
    // K-means clustering on genome space
    let k = Math.max(1, Math.floor(organisms.length / 20));
    let clusters = kmeans(organisms, k, (a, b) => {
      return a.genome.distanceTo(b.genome);
    });
    
    return clusters;
  }
  
  findMatchingSpecies(cluster) {
    for (let species of this.species) {
      let similarity = this.clusterSimilarity(cluster, species.members);
      if (similarity > 0.8) {
        return species;
      }
    }
    return null;
  }
  
  clusterSimilarity(cluster1, cluster2) {
    // Compare cluster centroids
    let centroid1 = this.calculateCentroid(cluster1);
    let centroid2 = this.calculateCentroid(cluster2);
    
    let distance = centroid1.distanceTo(centroid2);
    return 1.0 / (1.0 + distance);
  }
  
  announceSpeciation(newSpecies) {
    ui.showMessage(`New species emerged!`);
    effects.speciation(newSpecies.members);
    audio.play('speciation');
    xp.award(250);
    
    if (this.speciationEvents >= 10) {
      achievements.unlock('ADAPTIVE_RADIATION');
    }
  }
}
```

#### Level 12: Cultural Architect

**Goal:** Develop unique societal structures in 2+ groups

**New Mechanic:** **Cultural Evolution**

- Groups develop distinct traditions
- Traditions pass from generation to generation
- Cultural identity forms

**What Emerges:**

```
Group A (Mountain Dwellers):
â”œâ”€ Hierarchical (alpha leader)
â”œâ”€ Aggressive (defend territory)
â”œâ”€ Traditional (resist change)
â””â”€ Architecture: Stone structures

Group B (Valley Dwellers):
â”œâ”€ Egalitarian (consensus decision)
â”œâ”€ Peaceful (avoid conflict)
â”œâ”€ Innovative (try new things)
â””â”€ Architecture: Organic forms

Cultural Drift:
â”œâ”€ Groups become more different over time
â”œâ”€ Even if genetically similar
â”œâ”€ Culture shapes behavior more than genes
â””â”€ INSIGHT: Nature AND nurture
```

**Achievement:**

```
ğŸ›ï¸ FIRST CIVILIZATIONS (150 XP)
â””â”€ 2+ cultures with distinct traditions
â””â”€ Unlock: CultForge (full layer)
â””â”€ Unlock: Cultural trait editor
```

#### Level 13: Emergence Apprentice

**Goal:** Demonstrate cross-system interaction

**Challenge:** Language enables better hunting success

**Tutorial:**

```
1. Setup: Two groups
   â”œâ”€ Group A: High language ability, low hunting skill
   â”œâ”€ Group B: Low language ability, high hunting skill
   â””â”€ Same environment, same prey

2. Observe over 100 generations:
   
3. Group A: 
   â”œâ”€ Develops hunting language
   â”œâ”€ "Deer left", "Circle around", etc.
   â”œâ”€ Coordination improves
   â”œâ”€ Hunting success increases!
   â””â”€ Survives despite low initial skill

4. Group B:
   â”œâ”€ Cannot communicate well
   â”œâ”€ Hunts individually (inefficient)
   â”œâ”€ Lower success rate
   â””â”€ Population pressure

5. Show CROSS-SYSTEM EMERGENCE:
   LinguaForge â†’ EcoForge â†’ NeuroForge â†’ CultForge
   â””â”€ Language â†’ Hunting â†’ Intelligence â†’ Culture
   â””â”€ Everything affects everything
   
6. INSIGHT: "Emergence is systemic"
   â””â”€ You cannot understand one forge in isolation
   â””â”€ Reality is interconnected
   â””â”€ Mastery requires holistic thinking
```

**Achievement:**

```
âš¡ SYSTEMS THINKER (200 XP)
â””â”€ Demonstrate cross-forge interaction
â””â”€ Unlock: Tier 2 (World Shaper)
â””â”€ Unlock: Multi-forge visualization
```

---

### LifeForge Technical Details

#### Performance Optimization

```javascript
// Spatial hashing for efficient collision detection
class SpatialHash {
  constructor(cellSize) {
    this.cellSize = cellSize;
    this.grid = new Map();
  }
  
  clear() {
    this.grid.clear();
  }
  
  insert(entity) {
    let cells = this.getCells(entity);
    for (let cell of cells) {
      let key = this.getKey(cell.x, cell.y);
      if (!this.grid.has(key)) {
        this.grid.set(key, []);
      }
      this.grid.get(key).push(entity);
    }
  }
  
  getCells(entity) {
    // Get all cells this entity overlaps
    let minX = Math.floor((entity.position.x - entity.radius) / this.cellSize);
    let maxX = Math.floor((entity.position.x + entity.radius) / this.cellSize);
    let minY = Math.floor((entity.position.y - entity.radius) / this.cellSize);
    let maxY = Math.floor((entity.position.y + entity.radius) / this.cellSize);
    
    let cells = [];
    for (let x = minX; x <= maxX; x++) {
      for (let y = minY; y <= maxY; y++) {
        cells.push({x, y});
      }
    }
    return cells;
  }
  
  getNearby(entity) {
    let cells = this.getCells(entity);
    let nearby = new Set();
    
    for (let cell of cells) {
      let key = this.getKey(cell.x, cell.y);
      let entities = this.grid.get(key);
      if (entities) {
        for (let e of entities) {
          if (e !== entity) {
            nearby.add(e);
          }
        }
      }
    }
    
    return Array.from(nearby);
  }
  
  getKey(x, y) {
    return `${x},${y}`;
  }
}

// Object pooling for cells
class CellPool {
  constructor() {
    this.pool = [];
    this.poolSize = 1000;
    
    // Pre-allocate cells
    for (let i = 0; i < this.poolSize; i++) {
      this.pool.push(new Cell());
    }
  }
  
  acquire(genome, position, energy) {
    let cell;
    if (this.pool.length > 0) {
      cell = this.pool.pop();
      cell.reinitialize(genome, position, energy);
    } else {
      cell = new Cell(genome, position, energy);
    }
    return cell;
  }
  
  release(cell) {
    cell.reset();
    if (this.pool.length < this.poolSize) {
      this.pool.push(cell);
    }
  }
}
```

#### Rendering Optimization

```javascript
class LifeForgeRenderer {
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    
    // Offscreen canvas for entities
    this.offscreen = document.createElement('canvas');
    this.offscreen.width = canvas.width;
    this.offscreen.height = canvas.height;
    this.offscreenCtx = this.offscreen.getContext('2d');
    
    // Camera
    this.camera = {
      x: 0,
      y: 0,
      zoom: 1.0
    };
    
    // Render budget (target 60fps)
    this.maxRenderTime = 16; // milliseconds
  }
  
  render(simulation) {
    let startTime = performance.now();
    
    // Clear
    this.ctx.fillStyle = '#0a0e1a';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Apply camera transform
    this.ctx.save();
    this.ctx.translate(
      this.canvas.width / 2 - this.camera.x * this.camera.zoom,
      this.canvas.height / 2 - this.camera.y * this.camera.zoom
    );
    this.ctx.scale(this.camera.zoom, this.camera.zoom);
    
    // Frustum culling
    let visibleCells = this.frustumCull(simulation.cells);
    
    // Level of detail
    let lod = this.getLOD(visibleCells.length);
    
    // Render cells
    for (let cell of visibleCells) {
      this.renderCell(cell, lod);
      
      // Check render budget
      if (performance.now() - startTime > this.maxRenderTime) {
        break; // Skip remaining cells this frame
      }
    }
    
    // Restore transform
    this.ctx.restore();
    
    // UI (always on top)
    this.renderUI(simulation);
  }
  
  frustumCull(cells) {
    // Only render cells in viewport
    let margin = 100; // pixels outside viewport
    let left = this.camera.x - (this.canvas.width / (2 * this.camera.zoom)) - margin;
    let right = this.camera.x + (this.canvas.width / (2 * this.camera.zoom)) + margin;
    let top = this.camera.y - (this.canvas.height / (2 * this.camera.zoom)) - margin;
    let bottom = this.camera.y + (this.canvas.height / (2 * this.camera.zoom)) + margin;
    
    return cells.filter(cell => {
      return cell.position.x >= left &&
             cell.position.x <= right &&
             cell.position.y >= top &&
             cell.position.y <= bottom;
    });
  }
  
  getLOD(cellCount) {
    // Reduce detail when many cells
    if (cellCount < 100) return 'high';
    if (cellCount < 500) return 'medium';
    return 'low';
  }
  
  renderCell(cell, lod) {
    // Glow (only in high LOD)
    if (lod === 'high' && cell.energy > cell.maxEnergy * 0.3) {
      this.drawNeonGlow(
        cell.position.x,
        cell.position.y,
        cell.color,
        cell.energy / cell.maxEnergy,
        cell.radius * 1.5
      );
    }
    
    // Body
    this.ctx.fillStyle = cell.color;
    this.ctx.beginPath();
    this.ctx.arc(
      cell.position.x,
      cell.position.y,
      cell.radius,
      0, Math.PI * 2
    );
    this.ctx.fill();
    
    // Internal details (only in high LOD)
    if (lod === 'high') {
      // Nucleus
      this.ctx.fillStyle = this.lighten(cell.color, 0.3);
      this.ctx.beginPath();
      this.ctx.arc(
        cell.position.x,
        cell.position.y,
        cell.radius * 0.4,
        0, Math.PI * 2
      );
      this.ctx.fill();
      
      // Organelles
      for (let i = 0; i < 3; i++) {
        let angle = (i / 3) * Math.PI * 2;
        let x = cell.position.x + Math.cos(angle) * cell.radius * 0.6;
        let y = cell.position.y + Math.sin(angle) * cell.radius * 0.6;
        
        this.ctx.fillStyle = this.lighten(cell.color, 0.2);
        this.ctx.beginPath();
        this.ctx.arc(x, y, cell.radius * 0.2, 0, Math.PI * 2);
        this.ctx.fill();
      }
    }
  }
}
```

---
